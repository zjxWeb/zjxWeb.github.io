# python语法基础及一些易错点
## 基础语法及用法
1. ctrl + d 可以退出python的解释器  exit（）
2.	ipython 比较好用的python编辑器
3. 算术运算符
		// 向下取整 整除
		** 幂 运算符
4. 复数型 complex 主要用于科学计算 包含实部和虚部
5. long 长整数
6. type（） 判断数据类型    
7. 整数和字符串是不能进行运算的
8. int（x） 将x转化成 整型
9. float（x） 将x 转化成浮点型
10. input() 输入函数 字符串变量 = input（“提示信息”）
11. %% 输出% print("格式化字符串%1.2%%"%（变量1，变量2,...）)
12. ```
    if 条件：
    	执行语句
    else：
    	执行语句
    ```

13. 代码缩进为一个 <kbd>tab</kbd> j键，或者 **4** 个空格 —— **建议使用空格 ** 
    - 在python开发中 ，Tab和空格不要混用
14. ```python
    if 条件1：
    	满足条件1的执行语句
    elif 条件2：
    	满足条件2的执行语句
    elif 条件3：
    	满足条件3的执行语句
    else：
    	以上条件都不满足时，执行的语句
    ```

15. ```
    import random 随机数生成的工具包
    random.randint(1,10) 1到10 随机生成随机数
    ```
16. ```
    print()函数输出内容之后，会自动在内容末尾增加换行
    要使其不换行可以：end=“” print("*",end="")
    print("")换行
    ```
17. ```python
    函数的定义：
    def 函数名（形参1，形参2）：
    	""" 函数注释——后面会有提示 """
    	函数内容
        return 需要返回的内容 #return下的语句是不会被调用的
    函数名（实参1，实参2）#函数执行
    接收返回结果：变量 = 函数名（实参1，实参2）
    ```
    ​	<kbd>ctr+q</kbd>查看提示信息	
    ​	**函数不可以先调用，在定义——必须先定义在调用**
18. ```python
    # 九九乘法表 循环语句
    row = 1                                                          
    while row <= 9:                                                  
        col = 1                                                      
        while col<row+1:                                             
            print("%d * %d = %d" % (row,col,row*col),end="\t")       
            col += 1      
                          
        print("")         
        row += 1                                
    ```
19. ```python
	    # for循环
	    fruits = ['banana', 'apple',  'mango']
	    for index in range(len(fruits)):
	       print '当前水果 :', fruits[index]
	    else:
	        # 没有通过 break 退出循环，循环结束后，会执行的代码。
	    print "Good bye!"
    ```
  
	```
	
	     结果：当前水果 : banana
	     	 当前水果 : apple
	     	 当前水果 : mango
	     	 Good bye!
	
	```
	     
20. ```python
	    # 模块的使用
	    import 所要导入的模块名
	    模块名.要使用的函数/变量
	```

21. ```
    pyc 文件是由 python 解释器将 模块的源码转化为 字节码！ 提高执行速度！
    ```

22. ```python
    列表的定义
    专门用于存储 一串信息 
    列表用[] 定义， 数据 之间使用 ， 分隔
    列表的索引从 0 开始
    name_list = ["zhangsan","lisi","wangwu"]
    列表.sort() 升序排序
    列表.sort(reverse=True)降序排序
    列表.reverse()反转/逆序
    列表[索引]从列表中取值
    列表.index(数据)获取数据第一次出现的索引
    列表.insert(索引，数据)在指定位置插入数据
    列表.append(数据) 在末尾追加数据
    列表.extend(列表2) 将列表2的数据追加到列表1
    del列表[索引]删除指定索引的数据
    列表.remove(数据) 删除第一个出现的指定数据
    列表.pop() 删除末尾数据
    列表.pop(索引)删除指定索引数据
    列表.count()统计列表中某一数据出现的次数
    列表.len()返回列表的长度
    ```

23. ```
    在ipython3 中定义一个列表，eg：name_list = []
    输入 name_list. ，按下 tab 键，ipython 会提示列表能够使用的方法
    ```
24. 元组
    * 元组（tuple）与列表类似，不同之处在于元组中的 **元素不能修改**
    * **元组** 在python中有特定的应用场景。
    * 用于储存 **一串信息，数据**，之间使用  **，**分隔
    * 元组用 <kbd>()</kbd>定义
    * 元组的 **索引**从 <kbd>0</kbd>开始
    * eg：info_yuple = ("zhangsan",18,1.75)
    * 创建空元组 tuple = （）
      * **元组中只包含一个元素时，需要在元素后面添加逗号**
      * 取值 info.tuple[索引]
      * info.count（数据）统计数据在元组中出现的次数
      * info.index（数据）取索引
    * 应用场景
      * 可以使用 <kbd>for in</kbd>遍历元组
      * 开发中更多的应用场景：
        * **函数的参数和返回值**，一个函数可以接受 **任意多个参数**，或者  **一次返回多个数据**
        * **格式字符串**，格式化字符串后面的 <kbd>()</kbd>本质上就是一个元组
        * **让列表不可以被修改**，以保护数据安全

25. **元组和列表之间的转换**

    ​	

    - 使用<kbd> list()</kbd>函数可以吧元组转换成列表  
    - 使用 <kbd> tuple()</kbd>函数可以吧列表转换成元组

    

26. 字典

    * <kbd> dictionary</kbd>(字典) 是 **除列表以外** python 之中 **最灵活** 的数据类型

    * 字典同样可以用来 **存储多个数据**

      * 通常用于 存储  **描述一个**<kbd>物体</kbd>**的相关信息**

    * 和列表的关系

      * **列表**是 **有序**的对象集合
      * **字典** 是 **无序** 的对象集合

    * 字典是用 <kbd>{}</kbd>定义

    * 字典使用 **键值对** 储存数据，键值对之间用 **，**分隔

      * **键** <kbd>key</kbd>是索引
      * **值** <kbd>value</kbd>是数据
      * **键 和 值**之间使用 <kbd>：</kbd>是分隔
      * **键必须是唯一的**
      * **值**可以取任何数据类型，但 **键**只能使用 **字符串，数字或元组**

      ```python
      xiaoming = {"namme":"小明"，
      			"age":18,
      			"gender":True,
      			"height":1.75}
      ```

    * 字典的方法

      * xiaoming[键值]  取值
      * xiaoming["age"] = 18 增加/修改
      * xiaoming.pop("name") 删除
      * len（键名） 统计键值对数量
      * xiaoming.update(新的字典)  合并字典 **如果被合并的字典中包含已经存在的键值对，会覆盖原有的键值对**
      * xiaoming.clear()  清空字典
      * 字典.items()所有（key,value）元组列表

    * ```python
      #for 循环内部使用的 ` key 的变量` in ` in 字典`
      for k in xiaoming: 
      	print("%s:%s"%(k,xiaoming[k]))
      ```

    * **提示：在实际开发中，由于字典中每一个键值对保存数据类型是不同的，所以针对字典的循环遍历需求并不是很多**

    * ```python
      card_list = [{"name":"张三"，
                    "qq":"123"
                   }，
      			 {"name":"李四"，
                    "qq":"1213"
                   }
      			]
      ```

27. **字符串**

    * 大多数编程语言都是用 <kbd>""</kbd>来定义字符串

      * len(字符串) 字符串长多
      * 字符串.count(子字符串) 子字符串出现的次数
      * 字符串.index(子字符串) 子字符串出现的索引

    * ```
      .isdecimal() 单纯数字
      .isdigit() unicode
      .isnumeric() 可以判断各种数字   unicode
      都不能判断小数
      num_str = "\u00b2"输出平方的符号 unicode
      ```

28. 3 in （1，2，3） 是否存在3      3 not in （1，2，3） 是否不存在3

29. ```python
    # TODO（作者/邮件） 注释功能
    ```

30. **LINUX 上的 Shebang 符号 （#!）**

    * #! 这个符号叫做shebang 或者sha-bang
    * 在python文件中第一行添加     #！+路径
    * chmod +x file_name 添加可执行的权限
    * ./文件名，直接可以运行

31. 变量的引用

    * 变量和数据都是保存在 **内存** 中的
    * 在 python 中 **函数的参数传递**  以及 **返回值** 都是靠 **引用** 传递的
    * 引用的概念
      * **变量** 和 **数据** 是分开储存的
      * **数据** 保存在内存中的一个位置
      * **变量** 中保存着数据在内存中的地址
      * **变量** 中 **记录数据的地址** ，就叫做 **引用**
      * 使用 <kbd>id()</kbd> 函数可以查看变量中保存数据所在的 **内存地址**
      * **注意：**如果变量已经被定义，当给一个变量赋值的时候，本质上是 **修改了数据的引用**
        * 变量 **不再** 对之前的数据引用     **变量：便签纸                  数据：小盒子**
          * 变量 **改为** 对新复制的数据引用

32. **可变类型：** 列表，字典。  **注意：字典的key，只能为不可变类型。**

33. **哈希（hash）**

    * python 中内置有一个名叫 <Kbd>hash(o)</kbd>的函数

      * 接受一个 **不可变类型** 的数据作为参数
      * 返回结果是一个 **整数**。

    * 哈希  是一种算法，其作用就是提取数据的  **特征码（指纹）**

      * **相同的内容**得到 **相同的结果**
      * **不同的内容** 得到 **不同的结果**

    * 在 python 中，设置字典的 **键值对** 时，首先对 key  进行 hash 已决定如何在内存中保存字典的数据，以方便 后续 对字典的操作：增，删，改，查。

      * 键值对 的  key   必须时不可变类型的数据

      * 键值对 的 value  可以时任意类型的数据

      * **hash() 函数的用途**

        hash() 函数的对象字符不管有多长，返回的 hash 值都是固定长度的，也用于校验程序在传输过程中是否被第三方（木马）修改，如果程序（字符）在传输过程中被修改hash值即发生变化，如果没有被修改，则 hash 值和原始的 hash 值吻合，只要验证 hash 值是否匹配即可验证程序是否带木马（病毒）。

34. 在python中，时不允许直接修改全局变量的值。 如果默认使用复制语句，会在函数内部，定义一个局部变量。

35. **在函数内部修改全局变量的值**

    * **global + 变量** —— 后面的变量是一个全局变量

36. 全局变量 的定义：未来保证所有的函数都能够正确使用到全局变量，应该 **将全局变量定义在其他函数的上方**

37. **全局变量的命名**   在前面应该增加 **g_**  或者 **gl_** 的前缀

38. 函数的返回值

    * 如果函数 **内部处理的数据不确定，或者是否返回结果**，是根据 **实际的功能需求** 来决定的！
    * 如果希望一个函数 **执行完成后，想外界汇报执行结果**，就可以增加函数的返回值。

39. 函数返回多个数据  return 变量1，变量2      

40. 函数返回值接受    

    ```
    result = measure（）
    
    gl_temp,gl_wet = measure（）  | 函数接受变量[索引]
    ```

41. 交换两个数

    ```
    a = a + b
    b = a - b
    a = a - b
    ```

    ```
    a,b = (b,a)
    a,b =  b,a
    ```

42. 如果传递的参数是 **可变类型**，在函数内部，使用 **方法** 修改了数据的内容 **同样会影响到外部的数据**

43. 在python 中，**列表变量调用 +=  **本质上是在执行变量的  **extend（）**方法，不会修改变量的引用

44. **缺省参数应该在参数的末尾**

45. **多值参数**

    * 参数名前增加    **一个** *****  可以接受元组 *args

    * 参数名前增加 **两个 ***  可以接受字典  **kwarges

    * ```python
      函数名（1，2，3，4，name = "小明"，age = 18）
      ```

46. **元组和字典的 拆包**

    * 将一个 **元组变量** ，直接传递给 **arges**
    * 将一个 **字典变量**，直接传递给 **kwarges**
      * 此时就可以使用拆包了
        * 在 **元组变量前**，增加 **一个 ***
        * 在 **字典变量前**， 增加 **两个 * **

47. **函数的递归**

    * 函数内部的 **代码是相同的**，只是针对 **参数** 不同，**处理的结果不同**

    * 当 **参数满足一个条件**时，函数不再执行

      * **这个非常重要**，通常被称为递归的出口，否则 **会出现死循环**

      * ```python
        def sum_bumber(num):
        	print(num)
            if num == 1:
                return 1#递归的出口
            #自己调用自己
            sum_number(num - 1)
        sum_number(3)
        ```

## 面向对象（OOP）基本概念

1. **dir**内置函数  dir（函数名）

2. **定义类**

   ```python
   class 类名:
   	def 方法1（self，参数列表）：
   		pass
   	def 方法2（self，参数列表）：
   		pass
   ```

   ​	**类中方法的第一参数必须是 self**， 类名的规则要符合 **大驼峰命名法**

3. **创建对象**

   * ```
     对象名称 = 类名（）
     ```

4. **方法中的self参数**

   * 那一个对象调用的方法，self 就是哪一个对象的引用

   * self.name self类似于 js中的this

   * **在日常开发中，不推荐在类的外部  给对象增加属性**

   * **内置函数 初始化方法**：<kbd>__init__</kbd>——专门用来定义一个类 **具有哪些属性的方法**

     * ```python
       class Cat:
       	def __init__(self):
       		print("初始化方法")
       tom = cat()
       ```

   * 在 <kbd>__init__</kbd>方法内部使用<kbd>self.属性名 = 属性的初始值</kbd>就可以 **定义属性**

     * ```python
       class Cat:
       	def __init__(self):
       		print("初始化方法")
       		self .name = "TOm"
       tom = cat()	
       ```

   * 方法内部可以使用 <kbd>self.属性名 = 形参</kbd>接受外部传递的参数

   * 在创建对象时，使用 <kbd>类名（属性1，属性2...）</kbd>调用

   * 当一个 **对象被从内存中销毁**前，会 **自动** 调用  <kbd>__del__</kbd>

   * \_\_str\__ :能够打印 **自定义的内容**

     * ```python
       class Cat:
       	def __str__(self):#必须返回一个字符串
       		return "我是小猫：%s"%self.name
       tom = cat()	
       ```

   * 一个对象 的 **属性**，可以是 **另外一个类创建的对象**

   ```
   self.gun == None   判断是否为空
   ```

5. 身份运算符

   * **is **  是判断两个标识符是不是引用同一个对象    	 eg：  x is y，类似 id（x） == id（y）
   * **is not  **  是判断两个标识符是不是引用不同对象       eg：  x is  not y，类似 id（x） = id（y）

6. **is 与 == 区别**

   *  **is**  用于判断 **两个变量    引用对象是否为同一个**    相当于js中的 ===
   *  **==**  用于判断  **引用变量的值**  是否相等

7. 私有属性和私有方法

   * 在定义 **属性或方法时**，在  **属性或者方法名前**  增加 **两个下划线**， 定义的就是  **私有** 属性或者方法。  __age
   * **伪私有属性和私有方法**
     * 在日常开发中， **不要使用这种方式，访问对象的私有属性 或 私有方法**
     * <Kbd>python</kbd> 中，并没有 **真正意义**  的 **私有**
       * 在给 **属性** ，**方法**  命名时，实际是对 **名称**  做了一些特殊处理，使得外界无法访问到
       * **处理方式**：在 **名称**  前面机上<kbd> _类名</kbd>=><kbd>类名__名称</kbd>

8. **继承**

   ```
   class 类名（父类名）:
   	pass
   ```

9. dog 子类   animal 父类

   * dog  类是 animal  类的子类，animal 类是 dog 类的父类，dog类从 animal 类继承
   * dog 类是anilam 类的派生类，animal 类是 dog类的基类， dog类从amimal 类派生

10. **继承的传递性:** **子类**  拥有  **父类 以及  父类的父类**中封装的所有 **属性 和  方法**

11. ```python
    #如果父类不能满足需求，可以在子类重写父类的方法
    class Dod():
        def bark(self):
            print("汪汪叫")
    class xiaotianquan(Dod):
        def fly(self):
            print("我会飞")
         def bark(self):
            print("叫的很号挺")
    ```

12. **对父类的方法进行扩展**

    * **在子类中 重写** 父类的方法
    * 在需要的位置使用 <kbd>super().父类方法</kbd>  来调用父类方法的执行
    * 代码其他位置针对的子类的需求，编写  **子类特有的代码实现**
    * **关于 super（）**
      * 在 python 中 super 是一个 **特殊的类**
      * supper（） 就是  super 类创建出来的对象
      * **最常** 使用的场景就是在 **重写父类方法时，** 调用 **在父类中封装的方法实现**

13. **调用父类的方法**

    *  类名.方法名（self）  会出现递归调用， **出现死循环**
    *  推荐使用supper（）

14. **多进程**

    * **子类** 可以拥有 **多个父类**，并且具有  **所有父类** 的 **属性**  和  **方法**

    * ```python
      class 子类名（父类名1，父类名2...）:
      	pass
      ```

    * 如果 **父类之间**  存在 **同名的属性或者方法**，应该 **尽量避免**  使用多进程 

    * **python中的MRO----方法搜素顺序**

      * python 中针对 类  提供了一个 **内置属性**  \_\_mro\_\_  可以查看 **方法**  搜素顺讯

      * MRO ---- method  resolution order，主要用于 **多继承是判断  方法，属性  的调用路径**

      * ```
        print(c.__mro__)
        ```

15. object  是 python 为所有对象提供的 **基类** 提供有一些内置的属性和方法，可以使用  **dir**函数查看

16. 新式类与旧时（经典）类

    * **新式类：**以 object 为基类的类，**推荐使用**

    * **旧式类：** 不以 object 为基类的类，**不推荐使用**

    * 今后在定义父类是，**如果没有父类，建议统一继承自 object**

    * ```
      class 类名（object）：
      	pass
      ```

17. **多态**

    * **多态** 不同的 **子类对象** 调用相同的 **父类方法**， 产生不同的执行效果
      * **多态**  不同的 **子类对象**  调用相同的 **父类方法** ，产生不同的执行效果
      * 以 **继承**  和 **重写父类方法**  为前提
      * 是调用方法的技巧，**不会影响到类的内部设计 **

18. 术语 --- 实例

    1. 创建出来的 **对象**  叫做 **类**  的实例
    2. 创建对象的 **动作**  叫做  **实例化**
    3. **对象的属性**  叫做  **实例属性**
    4. **对象调用的方法** 叫做 **实例方法**

19. **类属性和实例属性**

    * **类属性** 就是给 **类对象** 中定义的 **属性**

    * 通常用来记录 **与这个类相关** 的特征

    * **类属性 不会用于** 记录 **具体对象的特征**

    * ```
      class tools():
      	count = 0 #类属性，向上查找机制
      类名.类属性
      对象.类属性   不推荐
      ```

20. **类方法**

    * **类方法** 就是针对 **类对象** 定义的方法

    * 在 **类方法** 内部可以直接访问 **类属性** 或者调用其他的 **类方法**

    * ```
      @classmethod
      def 类方法名（cls）：
      	pass
      ```

    * 在方法内部

      * 可以通过 **cls.**  访问类的属性
      * 也可以通过 **cls.** 调用其他的类方法

21. **静态方法**

    * 在开发时，如果需要在 **类** 中封装一个方法，这个方法：

      * 即 **不需要** 访问 **实例属性** 或者调用 **实例方法**
      * 也 **不需要** 访问 **类属性** 或者调用 **类方法**

    * 这个时候，可以吧这个方法封装成一个 **静态方法**

    * ```
      @staticmethod
      def 静态方法名（）：
      	pass
      ```

    * 通过 **类名.**  调用 **静态方法**

22. 类方法和实例方法的区别

    * 类方法在调用的时候直接可以  类名.类方法名
    * 实例方法  **必须先创建一个对象才可以**   对象名 = 类名（）

23. 类中的定义

    * **实例方法** --- 方法内部需要访问 **实例属性**
      * **实例方法**  内部可以使用 **类名.**访问类属性
    * **类方法** -- 方法内部 **只需要** 访问  **类属性**
    * **静态方法** -- 方法内部，不需要访问 **实例属性**  和 **类属性**
    * 如果方法内部即需要访问 **实例属性，**  又需要访问 **类属性**   ----  **实例方法**

## 单列

1. 单列模式

   * **设计模式** 是 **前人工作的总结和提炼**，通常，被广泛流传的设计模式都是针对 **某一特定问题**  的成熟解决方案

   * **目的-- 让类**创建的对象，在系统中 **只有  唯一的一个实例**

   * 每一次执行 **类名（）**  返回的对象，**内存地址是相同的**

   * 单列模式设计的应用场景

     * **音乐播放** 对象
     * **回收站** 对象
     * **打印机** 对象
     * ......

   * * \_\_new\_\_**方法** 是一个由 object 基类提供的 **内置的静态方法** 主要作用有两个：

       * 在内存中为对象 **分配空间**
       * **返回**对象的引用

     * python 的解释器获得对象的 **引用** 后，**将引用** 作为 **第一个参数**  传递给 \_\_init\_\_**方法**

     * **重写 \_\_new\_\_**方法 一定要  **return super().\_\_new\_\_(cls)**

     * 如果不返回则不会执行 \_\_init\_\_ 方法

     * ```python
       class MusicPlayer(object):
           # 记录第一个被创建对象的引用
           instance = None
           def __new__(cls, *args, **kwargs):
               if cls.instance is None:
                   cls.instance = super().__new__(cls)
               return cls.instance
       player1 = MusicPlayer()
       print(player1)
       
       player2 = MusicPlayer()
       print(player2)
        # player1和player2地址一样，即为单列模式对的特点
       ```

   * **让初始化动作**  只被  **执行一次**

     * **解决方法**  相当于设置一个开关

     * 定义一个类属性  init_flag  标记是否 **执行过初始化动作**，初始值为  flase

     * 在\_\_init\_\_   方法中 判断 init_flag ，如果为 false 就执行初始化动作

     * 然后将init_flag 设置为 true 

     * 这样，在此自动调用   _\_init\_\_    方法时， **初始化动作就不会被在此执行了**

     * ```python
       class MusicPlayer(object):
           # 记录第一个被创建对象的引用
           instance = None
       
           # 记录是否执行过初始化动作
           init_flag = False
           def __new__(cls, *args, **kwargs):
               if cls.instance is None:
                   cls.instance = super().__new__(cls)
               return cls.instance
           def __init__(self):
               if MusicPlayer.init_flag:
                   return
               print("初始化播放器")
               MusicPlayer.init_flag = True
       player1 = MusicPlayer()
       print(player1)
       
       player2 = MusicPlayer()
       print(player2)
        # player1和player2地址一样，即为单列模式对的特点
       ```

### 异常

1. 在开发中，如果 **对某些代码执行不能确定是否正确**  ，可以增加  <Kbd> try(尝试)</kbd>    来  **捕获异常**

   ```python
   try:
   	尝试执行的程序
   except：
   	出现错误的处理
   ```

2. 在程序执行时，可能会遇到  **不同类型的异常**  ，并且需要 **针对不同类型的异常**  ，  **做出不同的相应**，这个时候，就需要捕获错误类型了

   ```python
   try:
        # 尝试执行的代码
       pass
   except  错误类型1：
        # 针对错误类型1，对应的代码处理
   except (错误类型2,错误类型3):
        #  针对错误类型2 和 错误类型3 ，对应的代码处理
       pass
   except  Exception as result:
       print("未知错误 %S" % result)
   ```

   *  当python 解释器  **抛出异常时，**  **最后一行错误信息的第一个单词，就是错误类型**

3. 捕获未知错误

   * 如果希望程序 **无论出现何种问题** ，都不会因为 python 解释器 **抛出异常而被终止**，  可以在增加一个 **except**

     ```python
     except Exception as result:
     	print("未知错误%s" % result)
     ```

4. **异常的传递**

   * **异常的传递——** 当 **函数/方法** 执行  **出现异常**，  会  **将异常传递** 给 函数/方法  的  **调用一方**
   * 如果 **传递到主程序**，仍然 **没有异常处理，**  程序才会被终止
   * 提示
     * 在开发中，可以在主函数中增加 **异常捕获**
     * 而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的 **异常捕获** 中
     * 这样就不需要再代码中，增加大量的 **异常捕获， **  能够用保证在吗的整洁

5. **抛出  raise   异常**

   * 在开发中，除了  **代码执行出错**   python 解释器会 **抛出**  异常之外

   * 还可以根据 **应用程序**  特有的业务需求 **主动抛出异常**

   * **注意**

     * 当前函数 **只负责**  提示用户输入密码，如果 **密码长度不准确，** **需要其他的函数进行额外处理**
     * 因此可以 **抛出异常**， 由其他需要处理的函数 **捕获异常**

   * 抛出异常

   * python 中 提供了一个 Execption **异常类**

   * 在开发时，如果满足 **特定业务需求时，** 希望 **抛出异常**，可以：

     * 创建一个  Exception **的对象**
     * 使用 raise **关键字** 抛出 异常对象

     ```python
     def inout_password():
         pwd = input("请输入密码")
         if len(pwd) >= 8:
             return pwd
         print("主动抛出异常")
         ex = Exception("密码长度不够")
         raise  ex
     try:
         print(inout_password())
     except Exception as  result:
         print(result)
     ```

### 模块

1. **导入方式**

   ```
   import 模块1
   import 模块2
   ```

   * 导入之后

     * 通过  <kbd>模块名.</kbd>  使用 **模块提供的工具** —— **全局变量，函数，类**

   * **使用 as 指定模块的别名**

     * > **如果模块的名字太长**，可以使用 <kbd>as</kbd>  指定模块的名称，以方便在代码中的使用

       ```
       import 模块1 as  模块别名
       ```

       > 注意： **模块别名**  应该符合  **大驼峰命名法**
       >
       > 1.大驼峰，每一个单词的首字母都大写，例如：AnamialZoo，JavaScript中构造函数用的是大驼峰式写法。
       >
       > ​    2.小驼峰，第一个单词的首字母小写，后面的单词的首字母全部大写，例如：fontSize、backgroundColor。

   * **form ...** **import** **导入** 

     ```python
     #从模块中导入  某一工具
     form 模块名1  import 工具名
     ```

     * 导入之后

       * 不需要 通过 模块名.
       * 可以直接使用 **模块提供的工具** —— **函数，全局变量，类**

     * 注意：

       >如果 **两个模块**，存在 **同名的函数，**那么 **后导入模块的函数**， **会覆盖掉先导入的函数**
       >
       >>解决方式，可以 给其中的一个函数 用  as  起一个 别名
       >>
       >>> form 模块名  import 工具名 as 别名

   * **form... import *(知道)**  **不推荐使用**

     ```python
     #从  模块  导入 所有的工具
     import 模块名1  import *
     ```

2. **模块的搜素顺序【】**

   ​	python  的解释器在 **导入模块，会：**

   * 搜素  **当前目录** 指定模块名的文件， **如果有就直接导入**

   * 如果没有，在搜素 **系统目录**

     > 在开发中，给文件起名，不要和 **系统的模块文件重名**

     python 中每一个模块都有一个 内置属性  <kbd>\_\_file\_\_</kbd> **可以查看模块** 的完整路径

     ```python
     #实例
     import random
     #生成一个 0——10 的数字
     rand = random.randint(0,10)
     print（rand）
     ```

     >注意： 如果当前目录下，存在一个 random.py 的文件，程序就无法正常执行了！

   * 这个时候 python 的解释器会 **加载当前目录下的   random.py** 而不会加载 系统  random 模块

3. **原则——每一个文件应该都可以被导入的**

   * 一个 **独立的**  python **文件** 就是一个 **模块*

   * 在导入文件事，文件中 **所有没有任何缩进的代码都会被执行一遍**

     **实际开发场景**

     -  在实际开发中，每一个模块都是独立开发的，大多数都有专人负责
     -  **开发人员** 通常会在 **模块下方增加一些测试代码**
        - 仅在模块内使用，而被导入到其他文件中不需要执行

   * \_\_name\_\_  **属性**

     >_\_name\_\_  属性可以做到，测试模块的代码 **只在测试情况下被运行**，而在 **被导入时不会被执行**

     * _\_name\_\_  是python 的一个内置属性，记录着一个 **字符串**
     * **如果是被其他文件导入的**，  _\_name\_\_ **就是模块名**
     * **如果是当前执行的程序**， _\_name\_\_  是   _\_main\_\_ 

     ```python
     if __name__ == "__main__"
     	print(__name__)
     	print("输出语句")
     ```

     [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-begTvuf7-1576571998435)(C:\Users\Administrator\Desktop\python\测试.png)]

4. **包（package）**

   * **概念**

     * **包** 是一个 **包含多个模块** 的 **特殊目录**
     * 目录下有一个  **特殊的文件**  \_\_init\_\_.py
     * 包名的 **命名方式** 和变量名一直， **小写字母+ <kbd>_</kbd>**

   * 好处

     * 使用 <kbd>import包名</kbd>可以一次性导入 **包** 中 **所有的模块**

   * _\_init\_\_.py

     * 要在外界使用  **包**  中的模块，需要在 **_\_init\_\_.py** 中指定 **对外界提供的模块列表**

       ```python
       # 从当前目录 导入 模块列表
       from . import  send_message
       from . import  receive_message
       ```

5. **发布模块**

   * 制作压缩包

     * **创建 setup.py**

       * setup.py 的文件

         ```python
         from distutils.core import setup
         
         #This is a list of files to install, and where
         #(relative to the 'root' dir, where setup.py is)
         #You could be more specific.
         files = ["things/*"]
         
         setup(name = "appname", #包名
             version = "100", #版本
             description = "yadda yadda", #描述文件
             long_description = "sdsds" #完整的描述信息
             author = "myself and I", #作者
             author_email = "email@someplace.com",#作者邮箱
             url = "whatever",#主页
             py_modules = ["hm_message.send_message",
             			  " hm_message.receive_message"]
         )
         ```

       * 有关字典的详细信息：https://docs.python.org/2/distutils/apiref.html

     * 构建模块

       * ```python
         $ python3 setup.py build
         ```

     * 生成发布压缩包

       * ```python
         $ python3 setup.py sdist
         ```

   * **安装模块**

     * ```shell
       tar -zxvf hm_message-1.0.tar.gz
       sudo python2 setup.oy install
       ```

   * **卸载模块**

     * 直接从安装目录下，吧安装模块的 **目录 **  删除就可以了

6. **pip 安装第三方模块**

   * pip 是一个现代的，通用的 python 包管理工具

     ```shell
     pip3 install paygame
     pip3 uninstall paygame
     验证安装  python3 -m pygame.exaples.aliens
     ```

  ```
   
   * https://pip.pypa.io/en/stable/installing/

### 文件

1. **操作文件的函数**

   | 序列 | 函数/方法 | 说明                           |
   | :--: | :-------: | :----------------------------- |
   |  01  |   open    | 打开文件，并且返回文件操作对象 |
   |  02  |   read    | 将文件内容读取到内存           |
   |  03  |   write   | 将指定内容写入文件             |
   |  04  |   close   | 关闭文件                       |

   * open 函数负责打开文件，并且返回文件对象

   * read/write/close 三个方法都需要通过  **文件对象**  来调用

     >注意：**打开文件一定要记着关闭文件**

   * **文件指针**

     * **文件指针** 标记  **从哪个位置开始读取文件数据**
     * **当第一次打开**  文件时，通常 **文件指针会指向文件的开始位置**
     * 当执行  read  方法后，**文件指针**  会移动到 **读取内容的末尾**
       * 默认情况下会移动到 **文件末尾**

   * ```
     f = open("文件名"，“访问方式”)
  ```

     * | 访问方式 | 说明                                                         |
       | :------: | ------------------------------------------------------------ |
       |    r     | 以 **只读** 方式打开文件。文件的指针将会挡在文件 的开头，这是 **默认模式。** 如果文件不存在，抛出异常 |
       |    w     | 以 **只写** 方式打开文件。**如果文件存在会被覆盖**。如果问价不存在，创建新文件 |
       |    a     | 以 **追加** 方式打开文件。如果文件已存在，文件指针将会放在文件的结尾。如果文件不存在，在创建文件进行写入。 |
       |    r+    | 以 **读写** 当时打开文件。文件指针将会放在文件的开头。如果文件不存在，抛出异常。 |
       |    w+    | 以 **读写** 当时打开文件。 如果文件存在会被覆盖。如果不存在，创建新文件 |
       |    a+    | 以 **读写** 当时打开文件。如果文件已存在，文件指针将会放在文件的结尾。如果文件不存在，穿件文件进行写入 |
    
     * 提示
    
       * 频繁的移动文件指针，**会影响文件的读写频率**，开发中更多的时候回以， **只读 ，只写 **方式来操作文件

   * **安行读取文件内容**

     * read 方法默认会吧文件的 **所有内容 一次性读取到内存**

     **readline 方法**

     * readline **方法可以一次读取一行内容**
     * 方法执行后，会吧 **文件指针** 移动到下一行，准备在次读取

     **读取文件的正确姿势**

     ```python
     #打开文件
     file = open("README")
     
     while TRUE:
     	#读取一行内容 
     	text = file.readline()
     	#判断是否读取内容
     	if not text:
     		break
     		#每读取一行的末尾已经有一个 ”\n“
     	print(text,end="")
     #关闭文件
     file.close()
     ```

2. **文件/目录的常用管理操作**

   * **在 终端/文件浏览器**，中可以执行常规的 **文件/目录** 管理操作，例如：

     * 创建，重命名，删除，改变路径，查看内容，.......

   * 在python 中，如果希望通过程序实现上述功能，需要导入 <kbd>os</kbd> 模块

     **文件操作**

     | 序号 | 方法名 | 说明       | 示例                            |
     | ---- | ------ | ---------- | ------------------------------- |
     | 01   | rename | 重命名文件 | os.rename(源文件名，目标文件名) |
     | 02   | remove | 删除文件   | os.remove（文件名）             |

     **目录操作**

     | 序号 | 方法名     | 说明           | 示例                    |
     | ---- | ---------- | -------------- | ----------------------- |
     | 01   | listdir    | 目录创建       | os.listdir(目录名)      |
     | 02   | mkdir      | 创建目录       | os.mkdir(目录名)        |
     | 03   | rmdir      | 删除目录       | os.rmdir(目录名)        |
     | 04   | getcwd     | 获取当前目录   | os.getcwd()             |
     | 05   | chdir      | 修改工作目录   | os.chdir(目标目录)      |
     | 06   | path.isdir | 判断是否是文件 | os.path.isdir(文件路径) |

     > 提示： 文件或者目录操作都支持 **相对路径 和 绝对路径**

3. **文本文件的编码格式**

   * 文本文件储存的内容是基于 **字符编码**  的文件，常见的编码有  **ASCII** 编码，**UNICODE**  编码等

     >Python 2.x默认使用 ASCII编码
     >
     >Python 3.x默认使用  UTF-8 编码、

4. **ASCII 编码和 UNCODE编码**

   **ASCII编码**

   * 计算机中只有 256  个ASCII字符

   * 一个 ASCII 在内存中占用 **一个字符** 的空间

     * 8 个 0/1 的排列作何方式一共有 256中，也就是 2**8

       [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-j903ArQi-1576571998436)(C:\Users\Administrator\Desktop\python\timg.jpg)]

     UTF-**8编码格式**

   * 计算机中使用 **1-6个字节** 来表示一个 UTF-8 字符，涵盖了 **地球上几乎所有地区的文字*

   * 大多数汉子会使用 **3个字节** 表示

   * UTF-8  是 UNCODE 编码的一种编码格式

5. **Python2.X中 如何使用中文**

   * 在Python2.X 文件的 **第一行** 增加以下代码，解释器会以  utf-8 编码来处理 python 文件

     ```
     # *-* coding:utf8 *-*
     ```

     > 这方式是官方推荐使用的

   * 也可以使用

     ```
     # coding=utf8
     ```

     **unicode 字符串**

     * 在 python2.x 中即使指定了文件使用 utf-8 的编码格式，但是在遍历字符串时，仍然会 **以季节为单位遍历** 字符串

     * 要额能够 **正确遍历字符串，** 在第一字符串时，需要  **在字符串的引号前**，增减一个小写字母 ,<kbd>u</kbd>  ,告诉解释器这是一个 **unicode** 字符串（使用 utf-8 编码格式的字符串）

     * ```
       hello_str = u"hello"
       ```

### eval 函数

<kbd>eval</kbd>函数十分强大----**将字符串**  当成 **有效表达式**  来求值，并 **返回计算结果**

```python
# 基本的数学计算
In [1]: eval("1 + 1")
Out [1]:2
#字符串重复
In[2]: eval(" '*' * 10")
Out[2]:'**********'
#将字符串转换成列表
In[3]:type( eval("[1,2,3,4,5]"))
Out[3]: list
#将字符串转化成字典
In[4]:type( eval("{'name':'zang','age':30}"))
Out[4]: dict
```

**不要滥用 eval**

>在开发中千万不要使用 eval 直接转化 input  的结果

```python
__import__('os').system('ls')
```

* 等价代码

* ```python
  import os
  os.system("终端命令")
  ```

* 执行成功 返回0

* 执行失败返回错误信息



    



