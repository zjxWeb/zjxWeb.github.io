# çº¿ç¨‹æ± çš„å®ç°,åŠå…¶ç›¸å…³çŸ¥è¯†ç‚¹

> [ç›¸å…³å¯è¿è¡Œä»£ç ğŸ–±ï¸](https://gitee.com/chuangdu/cpp_threadpool.git)

> è¯¦ç»†å†…å®¹å¯çœ‹ [çˆ±ç¼–ç¨‹çš„å¤§ä¸™](https://subingwen.cn/)

## çº¿ç¨‹æ± çš„åŸç†

+ æˆ‘ä»¬ä½¿ç”¨çº¿ç¨‹çš„æ—¶å€™å°±å»åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œè¿™æ ·å®ç°èµ·æ¥éå¸¸ç®€ä¾¿ï¼Œä½†æ˜¯å°±ä¼šæœ‰ä¸€ä¸ªé—®é¢˜ï¼šå¦‚æœå¹¶å‘çš„çº¿ç¨‹æ•°é‡å¾ˆå¤šï¼Œå¹¶ä¸”æ¯ä¸ªçº¿ç¨‹éƒ½æ˜¯æ‰§è¡Œä¸€ä¸ªæ—¶é—´å¾ˆçŸ­çš„ä»»åŠ¡å°±ç»“æŸäº†ï¼Œè¿™æ ·é¢‘ç¹åˆ›å»ºçº¿ç¨‹å°±ä¼šå¤§å¤§é™ä½ç³»ç»Ÿçš„æ•ˆç‡ï¼Œå› ä¸ºé¢‘ç¹åˆ›å»ºçº¿ç¨‹å’Œé”€æ¯çº¿ç¨‹éœ€è¦æ—¶é—´ã€‚

+ é‚£ä¹ˆæœ‰æ²¡æœ‰ä¸€ç§åŠæ³•ä½¿å¾—çº¿ç¨‹å¯ä»¥å¤ç”¨ï¼Œå°±æ˜¯æ‰§è¡Œå®Œä¸€ä¸ªä»»åŠ¡ï¼Œå¹¶ä¸è¢«é”€æ¯ï¼Œè€Œæ˜¯å¯ä»¥ç»§ç»­æ‰§è¡Œå…¶ä»–çš„ä»»åŠ¡å‘¢ï¼Ÿ

+ çº¿ç¨‹æ± æ˜¯ä¸€ç§å¤šçº¿ç¨‹å¤„ç†å½¢å¼ï¼Œå¤„ç†è¿‡ç¨‹ä¸­å°†ä»»åŠ¡æ·»åŠ åˆ°é˜Ÿåˆ—ï¼Œç„¶ååœ¨åˆ›å»ºçº¿ç¨‹åè‡ªåŠ¨å¯åŠ¨è¿™äº›ä»»åŠ¡ã€‚çº¿ç¨‹æ± çº¿ç¨‹éƒ½æ˜¯åå°çº¿ç¨‹ã€‚æ¯ä¸ªçº¿ç¨‹éƒ½ä½¿ç”¨é»˜è®¤çš„å †æ ˆå¤§å°ï¼Œä»¥é»˜è®¤çš„ä¼˜å…ˆçº§è¿è¡Œï¼Œå¹¶å¤„äºå¤šçº¿ç¨‹å•å…ƒä¸­ã€‚å¦‚æœæŸä¸ªçº¿ç¨‹åœ¨æ‰˜ç®¡ä»£ç ä¸­ç©ºé—²ï¼ˆå¦‚æ­£åœ¨ç­‰å¾…æŸä¸ªäº‹ä»¶ï¼‰,åˆ™çº¿ç¨‹æ± å°†æ’å…¥å¦ä¸€ä¸ªè¾…åŠ©çº¿ç¨‹æ¥ä½¿æ‰€æœ‰å¤„ç†å™¨ä¿æŒç¹å¿™ã€‚å¦‚æœæ‰€æœ‰çº¿ç¨‹æ± çº¿ç¨‹éƒ½å§‹ç»ˆä¿æŒç¹å¿™ï¼Œä½†é˜Ÿåˆ—ä¸­åŒ…å«æŒ‚èµ·çš„å·¥ä½œï¼Œåˆ™çº¿ç¨‹æ± å°†åœ¨ä¸€æ®µæ—¶é—´ååˆ›å»ºå¦ä¸€ä¸ªè¾…åŠ©çº¿ç¨‹ä½†çº¿ç¨‹çš„æ•°ç›®æ°¸è¿œä¸ä¼šè¶…è¿‡æœ€å¤§å€¼ã€‚è¶…è¿‡æœ€å¤§å€¼çš„çº¿ç¨‹å¯ä»¥æ’é˜Ÿï¼Œä½†ä»–ä»¬è¦ç­‰åˆ°å…¶ä»–çº¿ç¨‹å®Œæˆåæ‰å¯åŠ¨ã€‚

+ åœ¨å„ä¸ªç¼–ç¨‹è¯­è¨€çš„è¯­ç§ä¸­éƒ½æœ‰çº¿ç¨‹æ± çš„æ¦‚å¿µï¼Œå¹¶ä¸”å¾ˆå¤šè¯­è¨€ä¸­ç›´æ¥æä¾›äº†çº¿ç¨‹æ± ï¼Œä½œä¸ºç¨‹åºçŒ¿ç›´æ¥ä½¿ç”¨å°±å¯ä»¥äº†ï¼Œä¸‹é¢ç»™å¤§å®¶ä»‹ç»ä¸€ä¸‹çº¿ç¨‹æ± çš„å®ç°åŸç†ï¼š

+ çº¿ç¨‹æ± çš„ç»„æˆä¸»è¦åˆ†ä¸º3ä¸ªéƒ¨åˆ†ï¼Œè¿™ä¸‰éƒ¨åˆ†é…åˆå·¥ä½œå°±å¯ä»¥å¾—åˆ°ä¸€ä¸ªå®Œæ•´çš„çº¿ç¨‹æ± ï¼š

  1. `ä»»åŠ¡é˜Ÿåˆ—ï¼Œå­˜å‚¨éœ€è¦å¤„ç†çš„ä»»åŠ¡ï¼Œç”±å·¥ä½œçš„çº¿ç¨‹æ¥å¤„ç†è¿™äº›ä»»åŠ¡`
     + é€šè¿‡çº¿ç¨‹æ± æä¾›çš„APIå‡½æ•°ï¼Œå°†ä¸€ä¸ªå¾…å¤„ç†çš„ä»»åŠ¡æ·»åŠ åˆ°ä»»åŠ¡é˜Ÿåˆ—ï¼Œæˆ–è€…ä»ä»»åŠ¡é˜Ÿåˆ—ä¸­åˆ é™¤
     + å·²å¤„ç†çš„ä»»åŠ¡ä¼šè¢«ä»ä»»åŠ¡é˜Ÿåˆ—ä¸­åˆ é™¤
     + çº¿ç¨‹æ± çš„ä½¿ç”¨è€…ï¼Œä¹Ÿå°±æ˜¯è°ƒç”¨çº¿ç¨‹æ± å‡½æ•°å¾€ä»»åŠ¡é˜Ÿåˆ—ä¸­æ·»åŠ ä»»åŠ¡çš„çº¿ç¨‹å°±æ˜¯ç”Ÿäº§è€…çº¿ç¨‹
  2. `å·¥ä½œçš„çº¿ç¨‹ï¼ˆä»»åŠ¡é˜Ÿåˆ—ä»»åŠ¡çš„æ¶ˆè´¹è€…ï¼‰ ï¼ŒNä¸ª`
     + çº¿ç¨‹æ± ä¸­ç»´æŠ¤äº†ä¸€å®šæ•°é‡çš„å·¥ä½œçº¿ç¨‹, ä»–ä»¬çš„ä½œç”¨æ˜¯æ˜¯ä¸åœçš„è¯»ä»»åŠ¡é˜Ÿåˆ—, ä»é‡Œè¾¹å–å‡ºä»»åŠ¡å¹¶å¤„ç†
     + å·¥ä½œçš„çº¿ç¨‹ç›¸å½“äºæ˜¯ä»»åŠ¡é˜Ÿåˆ—çš„æ¶ˆè´¹è€…è§’è‰²ï¼Œ
     + å¦‚æœä»»åŠ¡é˜Ÿåˆ—ä¸ºç©º, å·¥ä½œçš„çº¿ç¨‹å°†ä¼šè¢«é˜»å¡ (ä½¿ç”¨æ¡ä»¶å˜é‡/ä¿¡å·é‡é˜»å¡)
     + å¦‚æœé˜»å¡ä¹‹åæœ‰äº†æ–°çš„ä»»åŠ¡, ç”±ç”Ÿäº§è€…å°†é˜»å¡è§£é™¤, å·¥ä½œçº¿ç¨‹å¼€å§‹å·¥ä½œ
  3. `ç®¡ç†è€…çº¿ç¨‹ï¼ˆä¸å¤„ç†ä»»åŠ¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ï¼‰ï¼Œ1ä¸ª`
     + å®ƒçš„ä»»åŠ¡æ˜¯å‘¨æœŸæ€§çš„å¯¹ä»»åŠ¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡æ•°é‡ä»¥åŠå¤„äºå¿™çŠ¶æ€çš„å·¥ä½œçº¿ç¨‹ä¸ªæ•°è¿›è¡Œæ£€æµ‹
     + å½“ä»»åŠ¡è¿‡å¤šçš„æ—¶å€™, å¯ä»¥é€‚å½“çš„åˆ›å»ºä¸€äº›æ–°çš„å·¥ä½œçº¿ç¨‹
     + å½“ä»»åŠ¡è¿‡å°‘çš„æ—¶å€™, å¯ä»¥é€‚å½“çš„é”€æ¯ä¸€äº›å·¥ä½œçš„çº¿ç¨‹

  ![1](./src/1.png)

## Cè¯­è¨€å®ç°â€”â€”çº¿ç¨‹æ± 

> threadpool.h

```cpp
#ifndef _THREADPOOL_H
#define _THREADPOOL_H

typedef struct ThreadPool ThreadPool;
// åˆ›å»ºçº¿ç¨‹æ± å¹¶åˆå§‹åŒ–
ThreadPool *threadPoolCreate(int min, int max, int queueSize);

// é”€æ¯çº¿ç¨‹æ± 
int threadPoolDestroy(ThreadPool* pool);

// ç»™çº¿ç¨‹æ± æ·»åŠ ä»»åŠ¡
void threadPoolAdd(ThreadPool* pool, void(*func)(void*), void* arg);

// è·å–çº¿ç¨‹æ± ä¸­å·¥ä½œçš„çº¿ç¨‹çš„ä¸ªæ•°
int threadPoolBusyNum(ThreadPool* pool);

// è·å–çº¿ç¨‹æ± ä¸­æ´»ç€çš„çº¿ç¨‹çš„ä¸ªæ•°
int threadPoolAliveNum(ThreadPool* pool);

//////////////////////
// å·¥ä½œçš„çº¿ç¨‹(æ¶ˆè´¹è€…çº¿ç¨‹)ä»»åŠ¡å‡½æ•°
void* worker(void* arg);
// ç®¡ç†è€…çº¿ç¨‹ä»»åŠ¡å‡½æ•°
void* manager(void* arg);
// å•ä¸ªçº¿ç¨‹é€€å‡º
void threadExit(ThreadPool* pool);
#endif  // _THREADPOOL_H
```

> threadpool.c

```cpp
#include "threadpool.h"
#include<pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>

const int NUMBER = 2;
// ä»»åŠ¡ç»“æ„ä½“
typedef struct Task {
    void (*function)(void *arg); // ä»»åŠ¡å‡½æ•°
    void *arg; // å‚æ•°
}Task;


// çº¿ç¨‹æ± ç»“æ„ä½“
struct ThreadPool {
    // ä»»åŠ¡é˜Ÿåˆ—
    Task *taskQ;
    int queueCapacity;// é˜Ÿåˆ—å®¹é‡
    int queueSize; // é˜Ÿåˆ—ä¸­å®é™…ä»»åŠ¡æ•°
    int queueFront; // é˜Ÿå¤´  å–æ•°æ®
    int queueRear; // é˜Ÿå°¾  æ”¾æ•°æ®
    // ç®¡ç†è€…çº¿ç¨‹
    pthread_t managerID; // ç®¡ç†è€…çº¿ç¨‹ID
    // å·¥ä½œè€…çº¿ç¨‹
    pthread_t *threadIDs; // å­˜æ”¾çº¿ç¨‹IDçš„æ•°ç»„
    // çº¿ç¨‹èŒƒå›´
    int minNum; // æœ€å°çº¿ç¨‹æ•°
    int maxNum; // æœ€å¤§çº¿ç¨‹æ•°
    int busyNum;// æœ‰å¤šå°‘å·¥ä½œçš„çº¿ç¨‹
    int liveNum;// å½“å‰å­˜æ´»çš„çº¿ç¨‹
    int exitNum; // è¦é”€æ¯çš„çº¿ç¨‹ä¸ªæ•°
    pthread_mutex_t mutexPool;// é”æ•´ä¸ªçº¿ç¨‹æ± 
    pthread_mutex_t mutexBusy; // é”busyNumå˜é‡
    int shutdown; // æ˜¯ä¸æ˜¯è¦é”€æ¯çº¿ç¨‹æ± ï¼Œé”€æ¯ä¸º1ï¼Œä¸é”€æ¯ä¸º0
    // æ¡ä»¶å˜é‡
    pthread_cond_t notEmpty; // ä»»åŠ¡é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
    pthread_cond_t notFull; // ä»»åŠ¡é˜Ÿåˆ—æ˜¯å¦æ»¡äº†
};

ThreadPool* threadPoolCreate(int min, int max, int queueSize)
{
    ThreadPool* pool = (ThreadPool*)malloc(sizeof(ThreadPool));
    do 
    {
        if (pool == NULL)
        {
            printf("malloc threadpool fail...\n");
            break;
        }

        pool->threadIDs = (pthread_t*)malloc(sizeof(pthread_t) * max);
        if (pool->threadIDs == NULL)
        {
            printf("malloc threadIDs fail...\n");
            break;
        }
        memset(pool->threadIDs, 0, sizeof(pthread_t) * max);
        pool->minNum = min;
        pool->maxNum = max;
        pool->busyNum = 0;
        pool->liveNum = min;    // å’Œæœ€å°ä¸ªæ•°ç›¸ç­‰
        pool->exitNum = 0;

        if (pthread_mutex_init(&pool->mutexPool, NULL) != 0 ||
            pthread_mutex_init(&pool->mutexBusy, NULL) != 0 ||
            pthread_cond_init(&pool->notEmpty, NULL) != 0 ||
            pthread_cond_init(&pool->notFull, NULL) != 0)
        {
            printf("mutex or condition init fail...\n");
            break;
        }

        // ä»»åŠ¡é˜Ÿåˆ—
        pool->taskQ = (Task*)malloc(sizeof(Task) * queueSize);
        pool->queueCapacity = queueSize;
        pool->queueSize = 0;
        pool->queueFront = 0;
        pool->queueRear = 0;

        pool->shutdown = 0;

        // åˆ›å»ºçº¿ç¨‹
        pthread_create(&pool->managerID, NULL, manager, pool);
        for (int i = 0; i < min; ++i)
        {
            pthread_create(&pool->threadIDs[i], NULL, worker, pool);
        }
        return pool;
    } while (0);

    // é‡Šæ”¾èµ„æº
    if (pool && pool->threadIDs) free(pool->threadIDs);
    if (pool && pool->taskQ) free(pool->taskQ);
    if (pool) free(pool);

    return NULL;
}

int threadPoolDestroy(ThreadPool* pool)
{
    if (pool == NULL)
    {
        return -1;
    }

    // å…³é—­çº¿ç¨‹æ± 
    pool->shutdown = 1;
    // é˜»å¡å›æ”¶ç®¡ç†è€…çº¿ç¨‹
    pthread_join(pool->managerID, NULL);
    // å”¤é†’é˜»å¡çš„æ¶ˆè´¹è€…çº¿ç¨‹
    for (int i = 0; i < pool->liveNum; ++i)
    {
        pthread_cond_signal(&pool->notEmpty);
    }
    // é‡Šæ”¾å †å†…å­˜
    if (pool->taskQ)
    {
        free(pool->taskQ);
    }
    if (pool->threadIDs)
    {
        free(pool->threadIDs);
    }

    pthread_mutex_destroy(&pool->mutexPool);
    pthread_mutex_destroy(&pool->mutexBusy);
    pthread_cond_destroy(&pool->notEmpty);
    pthread_cond_destroy(&pool->notFull);

    free(pool);
    pool = NULL;

    return 0;
}


void threadPoolAdd(ThreadPool* pool, void(*func)(void*), void* arg)
{
    pthread_mutex_lock(&pool->mutexPool);
    while (pool->queueSize == pool->queueCapacity && !pool->shutdown)
    {
        // é˜»å¡ç”Ÿäº§è€…çº¿ç¨‹
        pthread_cond_wait(&pool->notFull, &pool->mutexPool);
    }
    if (pool->shutdown)
    {
        pthread_mutex_unlock(&pool->mutexPool);
        return;
    }
    // æ·»åŠ ä»»åŠ¡
    pool->taskQ[pool->queueRear].function = func;
    pool->taskQ[pool->queueRear].arg = arg;
    pool->queueRear = (pool->queueRear + 1) % pool->queueCapacity;
    pool->queueSize++;

    pthread_cond_signal(&pool->notEmpty);
    pthread_mutex_unlock(&pool->mutexPool);
}

int threadPoolBusyNum(ThreadPool* pool)
{
    pthread_mutex_lock(&pool->mutexBusy);
    int busyNum = pool->busyNum;
    pthread_mutex_unlock(&pool->mutexBusy);
    return busyNum;
}

int threadPoolAliveNum(ThreadPool* pool)
{
    pthread_mutex_lock(&pool->mutexPool);
    int aliveNum = pool->liveNum;
    pthread_mutex_unlock(&pool->mutexPool);
    return aliveNum;
}

void* worker(void* arg)
{
    ThreadPool* pool = (ThreadPool*)arg;

    while (1)
    {
        pthread_mutex_lock(&pool->mutexPool);
        // å½“å‰ä»»åŠ¡é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
        while (pool->queueSize == 0 && !pool->shutdown)
        {
            // é˜»å¡å·¥ä½œçº¿ç¨‹
            pthread_cond_wait(&pool->notEmpty, &pool->mutexPool);

            // åˆ¤æ–­æ˜¯ä¸æ˜¯è¦é”€æ¯çº¿ç¨‹
            if (pool->exitNum > 0)
            {
                pool->exitNum--;
                if (pool->liveNum > pool->minNum)
                {
                    pool->liveNum--;
                    pthread_mutex_unlock(&pool->mutexPool);
                    threadExit(pool);
                }
            }
        }

        // åˆ¤æ–­çº¿ç¨‹æ± æ˜¯å¦è¢«å…³é—­äº†
        if (pool->shutdown)
        {
            pthread_mutex_unlock(&pool->mutexPool);
            threadExit(pool);
        }

        // ä»ä»»åŠ¡é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªä»»åŠ¡
        Task task;
        task.function = pool->taskQ[pool->queueFront].function;
        task.arg = pool->taskQ[pool->queueFront].arg;
        // ç§»åŠ¨å¤´ç»“ç‚¹
        pool->queueFront = (pool->queueFront + 1) % pool->queueCapacity;
        pool->queueSize--;
        // è§£é”
        pthread_cond_signal(&pool->notFull);
        pthread_mutex_unlock(&pool->mutexPool);

        printf("thread %ld start working...\n", pthread_self());
        pthread_mutex_lock(&pool->mutexBusy);
        pool->busyNum++;
        pthread_mutex_unlock(&pool->mutexBusy);
        task.function(task.arg);
        free(task.arg);
        task.arg = NULL;

        printf("thread %ld end working...\n", pthread_self());
        pthread_mutex_lock(&pool->mutexBusy);
        pool->busyNum--;
        pthread_mutex_unlock(&pool->mutexBusy);
    }
    return NULL;
}

void* manager(void* arg)
{
    ThreadPool* pool = (ThreadPool*)arg;
    while (!pool->shutdown)
    {
        // æ¯éš”3sæ£€æµ‹ä¸€æ¬¡
        sleep(3);

        // å–å‡ºçº¿ç¨‹æ± ä¸­ä»»åŠ¡çš„æ•°é‡å’Œå½“å‰çº¿ç¨‹çš„æ•°é‡
        pthread_mutex_lock(&pool->mutexPool);
        int queueSize = pool->queueSize;
        int liveNum = pool->liveNum;
        pthread_mutex_unlock(&pool->mutexPool);

        // å–å‡ºå¿™çš„çº¿ç¨‹çš„æ•°é‡
        pthread_mutex_lock(&pool->mutexBusy);
        int busyNum = pool->busyNum;
        pthread_mutex_unlock(&pool->mutexBusy);

        // æ·»åŠ çº¿ç¨‹
        // ä»»åŠ¡çš„ä¸ªæ•°>å­˜æ´»çš„çº¿ç¨‹ä¸ªæ•° && å­˜æ´»çš„çº¿ç¨‹æ•°<æœ€å¤§çº¿ç¨‹æ•°
        if (queueSize > liveNum && liveNum < pool->maxNum)
        {
            pthread_mutex_lock(&pool->mutexPool);
            int counter = 0;
            for (int i = 0; i < pool->maxNum && counter < NUMBER
                && pool->liveNum < pool->maxNum; ++i)
            {
                if (pool->threadIDs[i] == 0)
                {
                    pthread_create(&pool->threadIDs[i], NULL, worker, pool);
                    counter++;
                    pool->liveNum++;
                }
            }
            pthread_mutex_unlock(&pool->mutexPool);
        }
        // é”€æ¯çº¿ç¨‹
        // å¿™çš„çº¿ç¨‹*2 < å­˜æ´»çš„çº¿ç¨‹æ•° && å­˜æ´»çš„çº¿ç¨‹>æœ€å°çº¿ç¨‹æ•°
        if (busyNum * 2 < liveNum && liveNum > pool->minNum)
        {
            pthread_mutex_lock(&pool->mutexPool);
            pool->exitNum = NUMBER;
            pthread_mutex_unlock(&pool->mutexPool);
            // è®©å·¥ä½œçš„çº¿ç¨‹è‡ªæ€
            for (int i = 0; i < NUMBER; ++i)
            {
                pthread_cond_signal(&pool->notEmpty);
            }
        }
    }
    return NULL;
}

void threadExit(ThreadPool* pool)
{
    pthread_t tid = pthread_self();
    for (int i = 0; i < pool->maxNum; ++i)
    {
        if (pool->threadIDs[i] == tid)
        {
            pool->threadIDs[i] = 0;
            printf("threadExit() called, %ld exiting...\n", tid);
            break;
        }
    }
    pthread_exit(NULL);
}
```

> main.c æµ‹è¯•

```cpp
#include "threadpool.h"
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>


void taskFunc(void* arg)
{
    int num = *(int*)arg;
    printf("thread %ld is working, number = %d\n",
        pthread_self(), num);
    sleep(1);
}

int main()
{
    // åˆ›å»ºçº¿ç¨‹æ± 
    ThreadPool* pool = threadPoolCreate(3, 10, 100);
    for (int i = 0; i < 100; ++i)
    {
        int* num = (int*)malloc(sizeof(int));
        *num = i + 100;
        threadPoolAdd(pool, taskFunc, num);
    }

    sleep(30);

    threadPoolDestroy(pool);
    return 0;
}
```

## socket é€šä¿¡â€”â€”çº¿ç¨‹æ± 

> server.c

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<arpa/inet.h>
// å¤šçº¿ç¨‹
#include<pthread.h>
#include "threadpool.h"

// ä¿¡æ¯ç»“æ„ä½“
struct SockInfo
{
    struct sockaddr_in cliaddr;
    int fd;
};

typedef struct PoolInfo
{
    ThreadPool* p;
    int fd;
}PoolInfo;
// struct SockInfo infos[512];

void working(void *arg);
void acceptConn(void* arg);

int main(){
    // 1. åˆ›å»ºç›‘å¬çš„å¥—æ¥å­—
    int fd = socket(AF_INET, SOCK_STREAM, 0);
    if(fd == -1){
        perror("socket");
        return -1;
    }
    // 2. ç»‘å®š
    struct sockaddr_in saddr;
    saddr.sin_family = AF_INET;
    saddr.sin_port = htons(9999);
    saddr.sin_addr.s_addr = INADDR_ANY; // 0 = 0.0.0.0
    int ret = bind(fd, (struct sockaddr*)&saddr, sizeof(saddr));
    if( ret == -1){
        perror("bind");
        return -1;
    }
    // 3. ç›‘å¬
    ret = listen(fd, 128);
    if(ret == -1){
        perror("listen");
        return -1;
    }

    // åˆå§‹åŒ–ç»“æ„ä½“æ•°ç»„
    // int max = sizeof(infos)/sizeof(infos[0]);
    // for(int i = 0; i < max; i++){
    //     bzero(&infos[i], sizeof(infos[i]));
    //     infos[i].fd = -1;// ç©ºé—²
    // }

    // åˆ›å»ºçº¿ç¨‹æ± 
    ThreadPool* pool = threadPoolCreate(3, 8, 100);
    PoolInfo* info =  (PoolInfo*)malloc(sizeof(PoolInfo));
    info->fd = fd;
    info->p = pool;
    threadPoolAdd(pool, acceptConn, info);

    pthread_exit(NULL);
    return 0;
}
void acceptConn(void* arg){
    PoolInfo* poolInfo = (PoolInfo*)arg;
    // 4. é˜»å¡ç­‰å¾…å®¢æˆ·ç«¯çš„è¿æ¥ï¼ˆä¸»çº¿ç¨‹ï¼‰
    // struct sockaddr_in cliaddr;
    int addelen = sizeof(struct sockaddr_in);
    while(1){
        struct SockInfo* pinfo;
        // for(int i = 0; i < max; i++){
        //     if(infos[i].fd == -1){
        //         pinfo = &infos[i];
        //         break;
        //     }
        // }
        pinfo = (struct SockInfo*)malloc(sizeof(struct SockInfo));
        // int cfd = accept(fd, (struct sockaddr*)&pinfo->cliaddr, &addelen);
        pinfo->fd = accept(poolInfo->fd, (struct sockaddr*)&pinfo->cliaddr, &addelen);
        // pinfo->fd = cfd;

        if(pinfo->fd == -1){
            perror("accept");
            break;
        }
        // åˆ›å»ºå­çº¿ç¨‹
        // pthread_t tid;
        // pthread_create(&tid, NULL, working, pinfo);
        // pthread_detach(tid);//joinæ˜¯é˜»å¡å‡½æ•°ï¼Œä¸»çº¿ç¨‹å›æ”¶èµ„æº

        // æ·»åŠ é€šä¿¡ä»»åŠ¡
        threadPoolAdd(poolInfo->p, working, pinfo);
    }
    close(poolInfo->fd);
}
void working(void* arg)
{
    struct SockInfo* pinfo = (struct SockInfo*)arg;
    // è¿æ¥æˆåŠŸï¼Œæ‰“å°å®¢æˆ·ç«¯çš„IPå’Œç«¯å£ä¿¡æ¯
    char ip[32];
    printf("å®¢æˆ·ç«¯çš„IPåœ°å€æ˜¯ï¼š%s, ç«¯å£æ˜¯ï¼š%d\n", inet_ntop(AF_INET, &pinfo->cliaddr.sin_addr.s_addr, ip, sizeof(ip)), ntohs(pinfo->cliaddr.sin_port));
    // 5. é€šä¿¡ï¼ˆå­çº¿ç¨‹ï¼‰
    while(1){
        char recvbuf[1024];
        int len = recv(pinfo->fd, recvbuf, sizeof(recvbuf), 0);
        if(len > 0 ){
            printf("å®¢æˆ·ç«¯è¯´ï¼š%s\n", recvbuf);
            send(pinfo->fd, recvbuf, len, 0);
        }
        else if(len == 0){
            printf("å®¢æˆ·ç«¯æ–­å¼€è¿æ¥\n");
            break;
        }
        else{
            perror("recv");
            break;
        }
    }

    // å…³é—­æ–‡ä»¶æè¿°ç¬¦
    close(pinfo->fd);
    // pinfo->fd = -1;

    // return NULL;
}
```

> client.c

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<arpa/inet.h>

int main(){
    // 1. åˆ›å»ºé€šä¿¡çš„å¥—æ¥å­—
    int fd = socket(AF_INET, SOCK_STREAM, 0);
    if(fd == -1){
        perror("socket");
        return -1;
    }
    // 2. ç»‘å®š
    struct sockaddr_in saddr;
    saddr.sin_family = AF_INET;
    saddr.sin_port = htons(9999);
    //saddr.sin_addr.s_addr = INADDR_ANY; // 0 = 0.0.0.0
    // è½¬å¤§ç«¯
    inet_pton(AF_INET,"127.0.0.1",&saddr.sin_addr.s_addr);
    int ret = connect(fd, (struct sockaddr*)&saddr, sizeof(saddr));
    if( ret == -1){
        perror("connect");
        return -1;
    }

    int number = 0;
    // 3. é€šä¿¡
    while(1){
        char recvbuf[1024];
        sprintf(recvbuf, "hello, I am client %d", number++);
        send(fd,recvbuf, strlen(recvbuf)+1, 0);

         // æ¸…ç©ºç¼“å­˜åŒºï¼Œå°†æ¥æ”¶åˆ°çš„æ•°æ®å­˜åˆ°buff
        memset(recvbuf, 0, sizeof(recvbuf));
        
        // æ¥æ”¶
        int len = recv(fd, recvbuf, sizeof(recvbuf), 0);
       
        if(len > 0 ){
            printf("server say%s\n", recvbuf);
        }
        else if(len == 0){ // æœåŠ¡ç«¯æ–­å¼€è¿æ¥
            printf("æœåŠ¡å™¨æ–­å¼€è¿æ¥\n");
            break;
        }
        else{
            perror("recv");
            break;
        }
        sleep(1);
    }

    // gå…³é—­
    close(fd);
    return 0;
}
```

> threadpool.c å’Œ threadpool.h å‚è€ƒä¸Šè¿°çº¿åŸå¸‚cè¯­è¨€å®ç°ç‰ˆæœ¬

## C++ å®ç°çº¿ç¨‹æ± 

> TaskQueue.h

```cpp
#pragma once
#include <queue>
#include <pthread.h>

// å®šä¹‰ä»»åŠ¡ç»“æ„ä½“
using callback = void(*)(void*);

template <typename T>
struct Task
{
    Task()
    {
        function = nullptr;
        arg = nullptr;
    }
    Task(callback f, void* arg)
    {
        function = f;
        this->arg = (T*)arg;
    }
    callback function;
    T* arg;
};

template <typename T>
// ä»»åŠ¡é˜Ÿåˆ—
class TaskQueue
{
public:
    TaskQueue();
    ~TaskQueue();

    // æ·»åŠ ä»»åŠ¡
    void addTask(Task<T>& task);
    void addTask(callback func, void* arg);

    // å–å‡ºä¸€ä¸ªä»»åŠ¡
    Task<T> takeTask();

    // è·å–å½“å‰é˜Ÿåˆ—ä¸­ä»»åŠ¡ä¸ªæ•°
    inline int taskNumber()
    {
        return m_queue.size();
    }

private:
    pthread_mutex_t m_mutex;    // äº’æ–¥é”
    std::queue<Task<T>> m_queue;   // ä»»åŠ¡é˜Ÿåˆ—
};
```

> TaskQueue.cpp

```cpp
#include "TaskQueue.h"

template <typename T>
TaskQueue<T>::TaskQueue()
{
    pthread_mutex_init(&m_mutex, NULL);
}
template <typename T>
TaskQueue<T>::~TaskQueue()
{
    pthread_mutex_destroy(&m_mutex);
}
template <typename T>
void TaskQueue<T>::addTask(Task<T>& task)
{
    pthread_mutex_lock(&m_mutex);
    m_queue.push(task);
    pthread_mutex_unlock(&m_mutex);
}
template <typename T>
void TaskQueue<T>::addTask(callback func, void* arg)
{
    pthread_mutex_lock(&m_mutex);
    // Task task;
    // task.function = func;
    // task.arg = arg;
    // m_queue.push(task);
    m_queue.push(Task<T>(func, arg));
    pthread_mutex_unlock(&m_mutex);
}
template <typename T>
Task<T> TaskQueue<T>::takeTask()
{
    Task<T> t;
    pthread_mutex_lock(&m_mutex);
    if (m_queue.size() > 0)
    {
        t = m_queue.front();
        m_queue.pop();
    }
    pthread_mutex_unlock(&m_mutex);
    return t;
}
```

> `ThreadPool.h`

```cpp
#pragma once
#include <pthread.h>
#include "TaskQueue.h"
#include "TaskQueue.cpp"

template <typename T>
class ThreadPool
{
public:
    ThreadPool(int min, int max);
    ~ThreadPool();

    // æ·»åŠ ä»»åŠ¡
    void addTask(Task<T> task);
    // è·å–å¿™çº¿ç¨‹çš„ä¸ªæ•°
    int getBusyNumber();
    // è·å–æ´»ç€çš„çº¿ç¨‹ä¸ªæ•°
    int getAliveNumber();

private:
    // å·¥ä½œçš„çº¿ç¨‹çš„ä»»åŠ¡å‡½æ•°
    static void* worker(void* arg);
    // ç®¡ç†è€…çº¿ç¨‹çš„ä»»åŠ¡å‡½æ•°
    static void* manager(void* arg);
    void threadExit();

private:
    pthread_mutex_t m_lock;
    pthread_cond_t m_notEmpty;
    pthread_t* m_threadIDs;
    pthread_t m_managerID;
    TaskQueue<T>* m_taskQ;
    int m_minNum;
    int m_maxNum;
    int m_busyNum;
    int m_aliveNum;
    int m_exitNum;
    bool m_shutdown = false;
};
```

> `ThreadPool.cpp`

```cpp
#include "ThreadPool.h"
#include <iostream>
#include <unistd.h>
#include <string.h>
using namespace std;

template <typename T>
ThreadPool<T>::ThreadPool(int minNum, int maxNum)
{
    // å®ä¾‹åŒ–ä»»åŠ¡é˜Ÿåˆ—
    m_taskQ = new TaskQueue<T>;
    do {
        // åˆå§‹åŒ–çº¿ç¨‹æ± 
        m_minNum = minNum;
        m_maxNum = maxNum;
        m_busyNum = 0;
        m_aliveNum = minNum;

        // æ ¹æ®çº¿ç¨‹çš„æœ€å¤§ä¸Šé™ç»™çº¿ç¨‹æ•°ç»„åˆ†é…å†…å­˜
        m_threadIDs = new pthread_t[maxNum];
        if (m_threadIDs == nullptr)
        {
            cout << "malloc thread_t[] å¤±è´¥...." << endl;;
            break;
        }
        // åˆå§‹åŒ–
        memset(m_threadIDs, 0, sizeof(pthread_t) * maxNum);
        // åˆå§‹åŒ–äº’æ–¥é”,æ¡ä»¶å˜é‡
        if (pthread_mutex_init(&m_lock, NULL) != 0 ||
            pthread_cond_init(&m_notEmpty, NULL) != 0)
        {
            cout << "init mutex or condition fail..." << endl;
            break;
        }

        /////////////////// åˆ›å»ºçº¿ç¨‹ //////////////////
        // æ ¹æ®æœ€å°çº¿ç¨‹ä¸ªæ•°, åˆ›å»ºçº¿ç¨‹
        for (int i = 0; i < minNum; ++i)
        {
            pthread_create(&m_threadIDs[i], NULL, worker, this);
            cout << "åˆ›å»ºå­çº¿ç¨‹, ID: " << to_string(m_threadIDs[i]) << endl;
        }
        // åˆ›å»ºç®¡ç†è€…çº¿ç¨‹, 1ä¸ª
        pthread_create(&m_managerID, NULL, manager, this);
    } while (0);
}

template <typename T>
ThreadPool<T>::~ThreadPool()
{
    m_shutdown = 1;
    // é”€æ¯ç®¡ç†è€…çº¿ç¨‹
    pthread_join(m_managerID, NULL);
    // å”¤é†’æ‰€æœ‰æ¶ˆè´¹è€…çº¿ç¨‹
    for (int i = 0; i < m_aliveNum; ++i)
    {
        pthread_cond_signal(&m_notEmpty);
    }

    if (m_taskQ) delete m_taskQ;
    if (m_threadIDs) delete[]m_threadIDs;
    pthread_mutex_destroy(&m_lock);
    pthread_cond_destroy(&m_notEmpty);
}

template <typename T>
void ThreadPool<T>::addTask(Task<T> task)
{
    if (m_shutdown)
    {
        return;
    }
    // æ·»åŠ ä»»åŠ¡ï¼Œä¸éœ€è¦åŠ é”ï¼Œä»»åŠ¡é˜Ÿåˆ—ä¸­æœ‰é”
    m_taskQ->addTask(task);
    // å”¤é†’å·¥ä½œçš„çº¿ç¨‹
    pthread_cond_signal(&m_notEmpty);
}

template <typename T>
int ThreadPool<T>::getAliveNumber()
{
    int threadNum = 0;
    pthread_mutex_lock(&m_lock);
    threadNum = m_aliveNum;
    pthread_mutex_unlock(&m_lock);
    return threadNum;
}

template <typename T>
int ThreadPool<T>::getBusyNumber()
{
    int busyNum = 0;
    pthread_mutex_lock(&m_lock);
    busyNum = m_busyNum;
    pthread_mutex_unlock(&m_lock);
    return busyNum;
}


// å·¥ä½œçº¿ç¨‹ä»»åŠ¡å‡½æ•°
template <typename T>
void* ThreadPool<T>::worker(void* arg)
{
    ThreadPool* pool = static_cast<ThreadPool*>(arg);
    // ä¸€ç›´ä¸åœçš„å·¥ä½œ
    while (true)
    {
        // è®¿é—®ä»»åŠ¡é˜Ÿåˆ—(å…±äº«èµ„æº)åŠ é”
        pthread_mutex_lock(&pool->m_lock);
        // åˆ¤æ–­ä»»åŠ¡é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º, å¦‚æœä¸ºç©ºå·¥ä½œçº¿ç¨‹é˜»å¡
        while (pool->m_taskQ->taskNumber() == 0 && !pool->m_shutdown)
        {
            cout << "thread " << to_string(pthread_self()) << " waiting..." << endl;
            // é˜»å¡çº¿ç¨‹
            pthread_cond_wait(&pool->m_notEmpty, &pool->m_lock);

            // è§£é™¤é˜»å¡ä¹‹å, åˆ¤æ–­æ˜¯å¦è¦é”€æ¯çº¿ç¨‹
            if (pool->m_exitNum > 0)
            {
                pool->m_exitNum--;
                if (pool->m_aliveNum > pool->m_minNum)
                {
                    pool->m_aliveNum--;
                    pthread_mutex_unlock(&pool->m_lock);
                    pool->threadExit();
                }
            }
        }
        // åˆ¤æ–­çº¿ç¨‹æ± æ˜¯å¦è¢«å…³é—­äº†
        if (pool->m_shutdown)
        {
            pthread_mutex_unlock(&pool->m_lock);
            pool->threadExit();
        }

        // ä»ä»»åŠ¡é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªä»»åŠ¡
        Task<T> task = pool->m_taskQ->takeTask();
        // å·¥ä½œçš„çº¿ç¨‹+1
        pool->m_busyNum++;
        // çº¿ç¨‹æ± è§£é”
        pthread_mutex_unlock(&pool->m_lock);
        // æ‰§è¡Œä»»åŠ¡
        cout << "thread " << to_string(pthread_self()) << " start working..." << endl;
        task.function(task.arg);
        delete task.arg;
        task.arg = nullptr;

        // ä»»åŠ¡å¤„ç†ç»“æŸ
        cout << "thread " << to_string(pthread_self()) << " end working...";
        pthread_mutex_lock(&pool->m_lock);
        pool->m_busyNum--;
        pthread_mutex_unlock(&pool->m_lock);
    }

    return nullptr;
}


// ç®¡ç†è€…çº¿ç¨‹ä»»åŠ¡å‡½æ•°
template <typename T>
void* ThreadPool<T>::manager(void* arg)
{
    ThreadPool* pool = static_cast<ThreadPool*>(arg);
    // å¦‚æœçº¿ç¨‹æ± æ²¡æœ‰å…³é—­, å°±ä¸€ç›´æ£€æµ‹
    while (!pool->m_shutdown)
    {
        // æ¯éš”5sæ£€æµ‹ä¸€æ¬¡
        sleep(5);
        // å–å‡ºçº¿ç¨‹æ± ä¸­çš„ä»»åŠ¡æ•°å’Œçº¿ç¨‹æ•°é‡
        //  å–å‡ºå·¥ä½œçš„çº¿ç¨‹æ± æ•°é‡
        pthread_mutex_lock(&pool->m_lock);
        int queueSize = pool->m_taskQ->taskNumber();
        int liveNum = pool->m_aliveNum;
        int busyNum = pool->m_busyNum;
        pthread_mutex_unlock(&pool->m_lock);

        // åˆ›å»ºçº¿ç¨‹
        const int NUMBER = 2;
        // å½“å‰ä»»åŠ¡ä¸ªæ•°>å­˜æ´»çš„çº¿ç¨‹æ•° && å­˜æ´»çš„çº¿ç¨‹æ•°<æœ€å¤§çº¿ç¨‹ä¸ªæ•°
        if (queueSize > liveNum && liveNum < pool->m_maxNum)
        {
            // çº¿ç¨‹æ± åŠ é”
            pthread_mutex_lock(&pool->m_lock);
            int num = 0;
            for (int i = 0; i < pool->m_maxNum && num < NUMBER
                && pool->m_aliveNum < pool->m_maxNum; ++i)
            {
                if (pool->m_threadIDs[i] == 0)
                {
                    pthread_create(&pool->m_threadIDs[i], NULL, worker, pool);
                    num++;
                    pool->m_aliveNum++;
                }
            }
            pthread_mutex_unlock(&pool->m_lock);
        }

        // é”€æ¯å¤šä½™çš„çº¿ç¨‹
        // å¿™çº¿ç¨‹*2 < å­˜æ´»çš„çº¿ç¨‹æ•°ç›® && å­˜æ´»çš„çº¿ç¨‹æ•° > æœ€å°çº¿ç¨‹æ•°é‡
        if (busyNum * 2 < liveNum && liveNum > pool->m_minNum)
        {
            pthread_mutex_lock(&pool->m_lock);
            pool->m_exitNum = NUMBER;
            pthread_mutex_unlock(&pool->m_lock);
            for (int i = 0; i < NUMBER; ++i)
            {
                pthread_cond_signal(&pool->m_notEmpty);
            }
        }
    }
    return nullptr;
}

// çº¿ç¨‹é€€å‡º
template <typename T>
void ThreadPool<T>::threadExit()
{
    pthread_t tid = pthread_self();
    for (int i = 0; i < m_maxNum; ++i)
    {
        if (m_threadIDs[i] == tid)
        {
            cout << "threadExit() function: thread " 
                << to_string(pthread_self()) << " exiting..." << endl;
            m_threadIDs[i] = 0;
            break;
        }
    }
    pthread_exit(NULL);
}
```

> main.cpp

```cpp
#include "ThreadPool.h"
#include "ThreadPool.cpp"
#include <unistd.h>
#include <stdio.h>
void taskFunc(void* arg)
{
    int num = *(int*)arg;
    printf("thread %ld is working, number = %d\n",
        pthread_self(), num);
    sleep(1);
}

int main()
{
    // åˆ›å»ºçº¿ç¨‹æ± 
    ThreadPool<int> pool(3,10);
    for (int i = 0; i < 100; ++i)
    {
        int* num = new int(i+100);
        pool.addTask(Task<int>(taskFunc, num));
    }

    sleep(20);
    return 0;
}
```

```shell
 g++ main.cpp ThreadPool.cpp TaskQueue.cpp -o app
```

## `C++11å®ç°çº¿ç¨‹æ± `

>  `ThreadPool.h`

```cpp
#pragma once
#include <thread>
#include <mutex>
#include <vector>
#include <queue>
#include <atomic>
#include <functional>
#include <condition_variable>
#include <map>
#include <future>
using namespace std;

// çº¿ç¨‹æ± ç±»
class ThreadPool
{
public:
    ThreadPool(int min = 4, int max = thread::hardware_concurrency());
    ~ThreadPool();
    void addTask(function<void()> f);

private:
    void manager();
    void worker();
private:
    thread* m_manager;
    map<thread::id, thread> m_workers; 
    vector<thread::id> m_ids; 
    int m_minThreads;
    int m_maxThreads; 
    atomic<bool> m_stop; 
    atomic<int> m_curThreads;
    atomic<int> m_idleThreads;
    atomic<int> m_exitNumber; 
    queue<function<void()>> m_tasks;
    mutex m_idsMutex; 
    mutex m_queueMutex;
    condition_variable m_condition;
};
```

> `ThreadPool.cpp`

```cpp
#include "threadpool.h"
#include <iostream>

ThreadPool::ThreadPool(int min, int max) : m_maxThreads(max),
m_minThreads(min), m_stop(false), m_exitNumber(0)
{
    //m_idleThreads = m_curThreads = max / 2;
    m_idleThreads = m_curThreads = min;
    cout << "çº¿ç¨‹æ•°é‡: " << m_curThreads << endl;
    m_manager = new thread(&ThreadPool::manager, this);
    for (int i = 0; i < m_curThreads; ++i)
    {
        thread t(&ThreadPool::worker, this);
        m_workers.insert(make_pair(t.get_id(), move(t)));
    }
}

ThreadPool::~ThreadPool()
{
    m_stop = true;
    m_condition.notify_all();
    for (auto& it : m_workers)
    {
        thread& t = it.second;
        if (t.joinable())
        {
            cout << "******** çº¿ç¨‹ " << t.get_id() << " å°†è¦é€€å‡ºäº†..." << endl;
            t.join();
        }
    }
    if (m_manager->joinable())
    {
        m_manager->join();
    }
    delete m_manager;
}

void ThreadPool::addTask(function<void()> f)
{
    {
        lock_guard<mutex> locker(m_queueMutex);
        m_tasks.emplace(f);
    }
    m_condition.notify_one();
}

void ThreadPool::manager()
{
    while (!m_stop.load())
    {
        this_thread::sleep_for(chrono::seconds(2));
        int idle = m_idleThreads.load();
        int current = m_curThreads.load();
        if (idle > current / 2 && current > m_minThreads)
        {
            m_exitNumber.store(2);
            m_condition.notify_all();
            unique_lock<mutex> lck(m_idsMutex);
            for (const auto& id : m_ids)
            {
                auto it = m_workers.find(id);
                if (it != m_workers.end())
                {
                    cout << "############## çº¿ç¨‹ " << (*it).first << "è¢«é”€æ¯äº†...." << endl;
                    (*it).second.join();
                    m_workers.erase(it);
                }
            }
            m_ids.clear();
        }
        else if (idle == 0 && current < m_maxThreads)
        {
            thread t(&ThreadPool::worker, this);
            cout << "+++++++++++++++ æ·»åŠ äº†ä¸€ä¸ªçº¿ç¨‹, id: " << t.get_id() << endl;
            m_workers.insert(make_pair(t.get_id(), move(t)));
            m_curThreads++;
            m_idleThreads++;
        }
    }
}

void ThreadPool::worker()
{
    while (!m_stop.load())
    {
        function<void()> task = nullptr;
        {
            unique_lock<mutex> locker(m_queueMutex);
            while (!m_stop && m_tasks.empty())
            {
                m_condition.wait(locker);
                if (m_exitNumber.load() > 0)
                {
                    cout << "----------------- çº¿ç¨‹ä»»åŠ¡ç»“æŸ, ID: " << this_thread::get_id() << endl;
                    m_exitNumber--;
                    m_curThreads--;
                    unique_lock<mutex> lck(m_idsMutex);
                    m_ids.emplace_back(this_thread::get_id());
                    return;
                }
            }

            if (!m_tasks.empty())
            {
                cout << "å–å‡ºä¸€ä¸ªä»»åŠ¡..." << endl;
                task = move(m_tasks.front());
                m_tasks.pop();
            }
        }

        if (task)
        {
            m_idleThreads--;
            task();
            m_idleThreads++;
        }
    }
}

void calc(int x, int y)
{
    int res = x + y;
    cout << "res = " << res << endl;
    this_thread::sleep_for(chrono::seconds(2));
}

int main()
{
    ThreadPool pool(4);
    for (int i = 0; i < 10; ++i)
    {
        auto func = bind(calc, i, i * 2);
        pool.addTask(func);
    }
    getchar();
    return 0;
}
```

+ é€šè¿‡æ·»åŠ ä»»åŠ¡çš„å‡½æ•°`addTask`å¯ä»¥å¾—çŸ¥ä»»åŠ¡å‡½æ•°è¿”å›å€¼ç±»å‹æ˜¯voidå¹¶ä¸”æ— å‚ï¼Œä½†æ˜¯æµ‹è¯•ç¨‹åºä¸­æ·»åŠ çš„ä»»åŠ¡å‡½æ•°æ˜¯`void calc(int x, int y)`æºå¸¦äº†ä¸¤ä¸ªå‚æ•°ï¼Œå¾ˆæ˜¾ç„¶å’Œä»»åŠ¡å‡½æ•°çš„å‚æ•°æ˜¯ç±»å‹æ˜¯ä¸åŒ¹é…çš„ï¼Œç¨‹åºä¸­çš„è§£å†³æ–¹æ¡ˆæ˜¯å¯¹å‡½æ•°å’Œå‚æ•°è¿›è¡Œç»‘å®šï¼š
  ```cpp
  auto func = bind(calc, i, i * 2);
  ```

  + è¿™æ ·å¾—åˆ°çš„å¯è°ƒç”¨å¯¹è±¡å°±æ˜¯æ— å‚çš„ã€‚é€šè¿‡è¿™ç§æ–¹å¼è¡¨é¢çœ‹èµ·æ¥åªèƒ½å­˜å‚¨æ— å‚å‡½æ•°çš„ä»»åŠ¡é˜Ÿåˆ—å°±å¯ä»¥å­˜å‚¨å¸¦ä»»æ„å‚æ•°çš„æœ‰å‚å‡½æ•°äº†ã€‚

+ `getchar();`é€šè¿‡è¯¥å‡½æ•°é˜»å¡ä¸»çº¿ç¨‹ï¼Œç¨‹åºè¿è¡Œå®Œæ¯•ä¹‹åï¼ŒæŒ‰ä»»æ„é”®è§£é™¤é˜»å¡ï¼Œä¸»çº¿ç¨‹æ‰§è¡Œå®Œæ¯•ï¼Œç¨‹åºï¼ˆè¿›ç¨‹ï¼‰ä¹Ÿå°±é€€å‡ºäº†ã€‚

## çº¿ç¨‹å¼‚æ­¥

[å¤šçº¿ç¨‹å¼‚æ­¥æ“ä½œ](https://subingwen.cn/cpp/async/)

### 1. `std::future`

+ `C++11`ä¸­å¢åŠ çš„çº¿ç¨‹ç±»ï¼Œä½¿å¾—æˆ‘ä»¬èƒ½å¤Ÿéå¸¸æ–¹ä¾¿çš„åˆ›å»ºå’Œä½¿ç”¨çº¿ç¨‹ï¼Œä½†æœ‰æ—¶ä¼šæœ‰äº›ä¸æ–¹ä¾¿ï¼Œæ¯”å¦‚éœ€è¦è·å–çº¿ç¨‹è¿”å›çš„ç»“æœï¼Œå°±ä¸èƒ½é€šè¿‡`join()`å¾—åˆ°ç»“æœï¼Œåªèƒ½é€šè¿‡ä¸€äº›é¢å¤–æ‰‹æ®µè·å¾—ï¼Œæ¯”å¦‚ï¼šå®šä¹‰ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œåœ¨å­çº¿ç¨‹ä¸­èµ‹å€¼ï¼Œåœ¨ä¸»çº¿ç¨‹ä¸­è¯»è¿™ä¸ªå˜é‡çš„å€¼ï¼Œæ•´ä¸ªè¿‡ç¨‹æ¯”è¾ƒç¹çã€‚`C++`æä¾›çš„çº¿ç¨‹åº“ä¸­æä¾›äº†ä¸€äº›ç±»ç”¨äºè®¿é—®å¼‚æ­¥æ“ä½œçš„ç»“æœã€‚
+ é‚£ä¹ˆï¼Œä»€ä¹ˆå«åšå¼‚æ­¥å‘¢ï¼Ÿ

![2](./src/2.png)

+ æˆ‘ä»¬å»æ˜Ÿå·´å…‹ä¹°å’–å•¡ï¼Œå› ä¸ºéƒ½æ˜¯ç°ç£¨çš„ï¼Œæ‰€ä»¥éœ€è¦ç­‰å¾…ï¼Œä½†æ˜¯æˆ‘ä»¬ä»˜å®Œè´¦åä¸ä¼šç«™åœ¨æŸœå°å‰æ­»ç­‰ï¼Œè€Œæ˜¯å»æ‰¾ä¸ªåº§ä½åä¸‹æ¥ç©ç©æ‰‹æœºæ‰“å‘ä¸€ä¸‹æ—¶é—´ï¼Œå½“åº—å‘˜æŠŠå’–å•¡ç£¨å¥½ä¹‹åï¼Œå°±ä¼šé€šçŸ¥æˆ‘ä»¬è¿‡å»å–ï¼Œè¿™å°±å«åšå¼‚æ­¥ã€‚

  + é¡¾å®¢ï¼ˆä¸»çº¿ç¨‹ï¼‰å‘èµ·ä¸€ä¸ªä»»åŠ¡ï¼ˆå­çº¿ç¨‹ç£¨å’–å•¡ï¼‰ï¼Œç£¨å’–å•¡çš„è¿‡ç¨‹ä¸­é¡¾å®¢å»åšåˆ«çš„äº‹æƒ…äº†ï¼Œæœ‰ä¸¤æ¡æ—¶é—´çº¿ï¼ˆå¼‚æ­¥ï¼‰
  + é¡¾å®¢ï¼ˆä¸»çº¿ç¨‹ï¼‰å‘èµ·ä¸€ä¸ªä»»åŠ¡ï¼ˆå­çº¿ç¨‹ç£¨å’–å•¡ï¼‰ï¼Œç£¨å’–å•¡çš„è¿‡ç¨‹ä¸­é¡¾å®¢æ²¡å»åšåˆ«çš„äº‹æƒ…è€Œæ˜¯æ­»ç­‰ï¼Œè¿™æ—¶å°±åªæœ‰ä¸€æ¡æ—¶é—´çº¿ï¼ˆåŒæ­¥ï¼‰ï¼Œæ­¤æ—¶æ•ˆç‡ç›¸å¯¹è¾ƒä½ã€‚

+ å› æ­¤å¤šçº¿ç¨‹ç¨‹åºä¸­çš„ä»»åŠ¡å¤§éƒ½æ˜¯å¼‚æ­¥çš„ï¼Œä¸»çº¿ç¨‹å’Œå­çº¿ç¨‹åˆ†åˆ«æ‰§è¡Œä¸åŒçš„ä»»åŠ¡ï¼Œå¦‚æœæƒ³è¦åœ¨ä¸»çº¿ä¸­å¾—åˆ°æŸä¸ªå­çº¿ç¨‹ä»»åŠ¡å‡½æ•°è¿”å›çš„ç»“æœå¯ä»¥ä½¿ç”¨C++11æä¾›çš„`std:future`ç±»ï¼Œè¿™ä¸ªç±»éœ€è¦å’Œå…¶ä»–ç±»æˆ–å‡½æ•°æ­é…ä½¿ç”¨ï¼Œå…ˆæ¥ä»‹ç»ä¸€ä¸‹è¿™ä¸ªç±»çš„`API`å‡½æ•°ï¼š

<!-- tabs:start -->

#### **ç±»çš„å®šä¹‰**

> é€šè¿‡ç±»çš„å®šä¹‰å¯ä»¥å¾—çŸ¥ï¼Œfutureæ˜¯ä¸€ä¸ªæ¨¡æ¿ç±»ï¼Œä¹Ÿå°±æ˜¯è¿™ä¸ªç±»å¯ä»¥å­˜å‚¨ä»»æ„æŒ‡å®šç±»å‹çš„æ•°æ®ã€‚

```cpp
// å®šä¹‰äºå¤´æ–‡ä»¶ <future>
template< class T > class future;
template< class T > class future<T&>;
template<>          class future<void>;
```

#### **æ„é€ å‡½æ•°**

```cpp
// â‘ 
future() noexcept;
// â‘¡
future( future&& other ) noexcept;
// â‘¢
future( const future& other ) = delete;
```

> + æ„é€ å‡½æ•°â‘ ï¼šé»˜è®¤æ— å‚æ„é€ å‡½æ•°
> + æ„é€ å‡½æ•°â‘¡ï¼šç§»åŠ¨æ„é€ å‡½æ•°ï¼Œè½¬ç§»èµ„æºçš„æ‰€æœ‰æƒ
> + æ„é€ å‡½æ•°â‘¢ï¼šä½¿ç”¨=deleteæ˜¾ç¤ºåˆ é™¤æ‹·è´æ„é€ å‡½æ•°, ä¸å…è®¸è¿›è¡Œå¯¹è±¡ä¹‹é—´çš„æ‹·è´

#### **å¸¸ç”¨æˆå‘˜å‡½æ•°ï¼ˆ`public`)**

+ ä¸€èˆ¬æƒ…å†µä¸‹ä½¿ç”¨=è¿›è¡Œèµ‹å€¼æ“ä½œå°±è¿›è¡Œå¯¹è±¡çš„æ‹·è´ï¼Œä½†æ˜¯`future`å¯¹è±¡ä¸å¯ç”¨å¤åˆ¶ï¼Œå› æ­¤ä¼šæ ¹æ®å®é™…æƒ…å†µè¿›è¡Œå¤„ç†ï¼š
  + å¦‚æœ`other`æ˜¯å³å€¼ï¼Œé‚£ä¹ˆè½¬ç§»èµ„æºçš„æ‰€æœ‰æƒ
  + å¦‚æœ`other`æ˜¯éå³å€¼ï¼Œä¸å…è®¸è¿›è¡Œå¯¹è±¡ä¹‹é—´çš„æ‹·è´ï¼ˆ`è¯¥å‡½æ•°è¢«æ˜¾ç¤ºåˆ é™¤ç¦æ­¢ä½¿ç”¨`ï¼‰

```cpp
future& operator=( future&& other ) noexcept; //noexceptäºæŒ‡ç¤ºä¸€ä¸ªå‡½æ•°æ˜¯å¦å¯èƒ½æŠ›å‡ºå¼‚å¸¸ã€‚åœ¨å‡½æ•°å£°æ˜æˆ–å®šä¹‰æ—¶ä½¿ç”¨ noexcept å…³é”®å­—ï¼Œå¯ä»¥å‘Šè¯‰ç¼–è¯‘å™¨è¯¥å‡½æ•°ä¸ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œæˆ–è€…è¯¥å‡½æ•°å¯èƒ½ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚
future& operator=( const future& other ) = delete;
```

+ å–å‡º`future`å¯¹è±¡å†…éƒ¨ä¿å­˜çš„æ•°æ®ï¼Œå…¶ä¸­`void get()`æ˜¯ä¸º`future<void>`å‡†å¤‡çš„ï¼Œæ­¤æ—¶å¯¹è±¡å†…éƒ¨ç±»å‹å°±æ˜¯`void`ï¼Œè¯¥å‡½æ•°æ˜¯ä¸€ä¸ªé˜»å¡å‡½æ•°ï¼Œå½“å­çº¿ç¨‹çš„æ•°æ®å°±ç»ªåè§£é™¤é˜»å¡å°±èƒ½å¾—åˆ°ä¼ å‡ºçš„æ•°å€¼äº†ã€‚

```cpp
T get();
T& get();
void get();
```

+ å› ä¸º`future`å¯¹è±¡å†…éƒ¨å­˜å‚¨çš„æ˜¯å¼‚æ­¥çº¿ç¨‹ä»»åŠ¡æ‰§è¡Œå®Œæ¯•åçš„ç»“æœï¼Œæ˜¯åœ¨è°ƒç”¨ä¹‹åçš„å°†æ¥å¾—åˆ°çš„ï¼Œå› æ­¤å¯ä»¥é€šè¿‡è°ƒç”¨`wait()`æ–¹æ³•ï¼Œé˜»å¡å½“å‰çº¿ç¨‹ï¼Œç­‰å¾…è¿™ä¸ªå­çº¿ç¨‹çš„ä»»åŠ¡æ‰§è¡Œå®Œæ¯•ï¼Œä»»åŠ¡æ‰§è¡Œå®Œæ¯•å½“å‰çº¿ç¨‹çš„é˜»å¡ä¹Ÿå°±è§£é™¤äº†

```cpp
void wait() const;
```

+ å¦‚æœå½“å‰çº¿ç¨‹`wait()`æ–¹æ³•å°±ä¼šæ­»ç­‰ï¼Œç›´åˆ°å­çº¿ç¨‹ä»»åŠ¡æ‰§è¡Œå®Œæ¯•å°†è¿”å›å€¼å†™å…¥åˆ°`future`å¯¹è±¡ä¸­ï¼Œè°ƒç”¨`wait_for()`åªä¼šè®©çº¿ç¨‹é˜»å¡ä¸€å®šçš„æ—¶é•¿ï¼Œä½†æ˜¯è¿™æ ·å¹¶ä¸èƒ½ä¿è¯å¯¹åº”çš„é‚£ä¸ªå­çº¿ç¨‹ä¸­çš„ä»»åŠ¡å·²ç»æ‰§è¡Œå®Œæ¯•äº†ã€‚

  + `wait_until()`å’Œ`wait_for()`å‡½æ•°åŠŸèƒ½æ˜¯å·®ä¸å¤šï¼Œå‰è€…æ˜¯`é˜»å¡åˆ°æŸä¸€æŒ‡å®šçš„æ—¶é—´ç‚¹`ï¼Œåè€…æ˜¯`é˜»å¡ä¸€å®šçš„æ—¶é•¿`ã€‚

```cpp
template< class Rep, class Period >
std::future_status wait_for( const std::chrono::duration<Rep,Period>& timeout_duration ) const;

template< class Clock, class Duration >
std::future_status wait_until( const std::chrono::time_point<Clock,Duration>& timeout_time ) const;
```

> `å½“wait_until()`å’Œ`wait_for()`å‡½æ•°è¿”å›ä¹‹åï¼Œå¹¶ä¸èƒ½ç¡®å®šå­çº¿ç¨‹å½“å‰çš„çŠ¶æ€ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦åˆ¤æ–­å‡½æ•°çš„è¿”å›å€¼ï¼Œè¿™æ ·å°±èƒ½çŸ¥é“å­çº¿ç¨‹å½“å‰çš„çŠ¶æ€äº†ï¼š

|           å¸¸é‡            |                     è§£é‡Š                     |
| :-----------------------: | :------------------------------------------: |
| `future_status::deferred` |           å­çº¿ç¨‹ä¸­çš„ä»»åŠ¡å‡½ä»æœªå¯åŠ¨           |
|  `future_status::ready`   |    å­çº¿ç¨‹ä¸­çš„ä»»åŠ¡å·²ç»æ‰§è¡Œå®Œæ¯•ï¼Œç»“æœå·²å°±ç»ª    |
| `future_status::timeout`  | å­çº¿ç¨‹ä¸­çš„ä»»åŠ¡æ­£åœ¨æ‰§è¡Œä¸­ï¼ŒæŒ‡å®šç­‰å¾…æ—¶é•¿å·²ç”¨å®Œ |

<!-- tabs:end -->

### 2. `std::promise`

>  `std::promise`æ˜¯ä¸€ä¸ªååŠ©çº¿ç¨‹èµ‹å€¼çš„ç±»ï¼Œå®ƒèƒ½å¤Ÿå°†æ•°æ®å’Œfutureå¯¹è±¡ç»‘å®šèµ·æ¥ï¼Œä¸ºè·å–çº¿ç¨‹å‡½æ•°ä¸­çš„æŸä¸ªå€¼æä¾›ä¾¿åˆ©ã€‚

#### 2.1 ç±»æˆå‘˜å‡½æ•°

<!-- tabs:start -->

#### **ç±»å®šä¹‰**

> é€šè¿‡`std::promise`ç±»çš„å®šä¹‰å¯ä»¥å¾—çŸ¥ï¼Œè¿™ä¹Ÿæ˜¯ä¸€ä¸ªæ¨¡æ¿ç±»ï¼Œæˆ‘ä»¬è¦åœ¨çº¿ç¨‹ä¸­ä¼ é€’ä»€ä¹ˆç±»å‹çš„æ•°æ®ï¼Œæ¨¡æ¿å‚æ•°å°±æŒ‡å®šä¸ºä»€ä¹ˆç±»å‹ã€‚

```cpp
// å®šä¹‰äºå¤´æ–‡ä»¶ <future>
template< class R > class promise;
template< class R > class promise<R&>;
template<>          class promise<void>;
```

#### **æ„é€ å‡½æ•°**

```cpp
// â‘ 
promise();
// â‘¡
promise( promise&& other ) noexcept;
// â‘¢
promise( const promise& other ) = delete;
```

1. æ„é€ å‡½æ•°â‘ ï¼šé»˜è®¤æ„é€ å‡½æ•°ï¼Œå¾—åˆ°ä¸€ä¸ªç©ºå¯¹è±¡
2. æ„é€ å‡½æ•°â‘¡ï¼šç§»åŠ¨æ„é€ å‡½æ•°
3. æ„é€ å‡½æ•°â‘¢ï¼šä½¿ç”¨`=delete`æ˜¾ç¤ºåˆ é™¤æ‹·è´æ„é€ å‡½æ•°, ä¸å…è®¸è¿›è¡Œå¯¹è±¡ä¹‹é—´çš„æ‹·è´

#### **å…¬å…±æˆå‘˜å‡½æ•°**

> åœ¨`std::promise`ç±»å†…éƒ¨ç®¡ç†ç€ä¸€ä¸ª`future`ç±»å¯¹è±¡ï¼Œè°ƒç”¨`get_future()`å°±å¯ä»¥å¾—åˆ°è¿™ä¸ª`future`å¯¹è±¡äº†

```cpp
std::future<T> get_future();
```

+ å­˜å‚¨è¦ä¼ å‡ºçš„ `value` å€¼ï¼Œå¹¶ç«‹å³è®©çŠ¶æ€å°±ç»ªï¼Œè¿™æ ·æ•°æ®è¢«ä¼ å‡ºå…¶å®ƒçº¿ç¨‹å°±å¯ä»¥å¾—åˆ°è¿™ä¸ªæ•°æ®äº†ã€‚é‡è½½çš„ç¬¬å››ä¸ªå‡½æ•°æ˜¯
+ `promise<void>`ç±»å‹çš„å¯¹è±¡å‡†å¤‡çš„ã€‚

```cpp
void set_value( const R& value );
void set_value( R&& value );
void set_value( R& value );
void set_value();
```

+ å­˜å‚¨è¦ä¼ å‡ºçš„ `value` å€¼ï¼Œä½†æ˜¯ä¸ç«‹å³ä»¤çŠ¶æ€å°±ç»ªã€‚åœ¨å½“å‰çº¿ç¨‹é€€å‡ºæ—¶ï¼Œå­çº¿ç¨‹èµ„æºè¢«é”€æ¯ï¼Œå†ä»¤çŠ¶æ€å°±ç»ªã€‚

```cpp
void set_value_at_thread_exit( const R& value );
void set_value_at_thread_exit( R&& value );
void set_value_at_thread_exit( R& value );
void set_value_at_thread_exit();
```

<!-- tabs:end -->

#### 2.2 promiseçš„ä½¿ç”¨

> é€šè¿‡promiseä¼ é€’æ•°æ®çš„è¿‡ç¨‹ä¸€å…±åˆ†ä¸º5æ­¥ï¼š

1. åœ¨ä¸»çº¿ç¨‹ä¸­åˆ›å»º`std::promise`å¯¹è±¡
2. å°†è¿™ä¸ª`std::promise`å¯¹è±¡é€šè¿‡å¼•ç”¨çš„æ–¹å¼ä¼ é€’ç»™å­çº¿ç¨‹çš„ä»»åŠ¡å‡½æ•°
3. åœ¨å­çº¿ç¨‹ä»»åŠ¡å‡½æ•°ä¸­ç»™`std::promise`å¯¹è±¡èµ‹å€¼
4. åœ¨ä¸»çº¿ç¨‹ä¸­é€šè¿‡`std::promise`å¯¹è±¡å–å‡ºç»‘å®šçš„`future`å®ä¾‹å¯¹è±¡
5. é€šè¿‡å¾—åˆ°çš„`future`å¯¹è±¡å–å‡ºå­çº¿ç¨‹ä»»åŠ¡å‡½æ•°ä¸­è¿”å›çš„å€¼ã€‚

<!-- tabs:start -->

#### **å­çº¿ç¨‹ä»»åŠ¡å‡½æ•°æ‰§è¡ŒæœŸé—´ï¼Œè®©çŠ¶æ€å°±ç»ª**

```cpp
#include <iostream>
#include <thread>
#include <future>
using namespace std;

int main()
{
    promise<int> pr;
    thread t1([](promise<int> &p) {
        p.set_value(100);
        this_thread::sleep_for(chrono::seconds(3));
        cout << "ç¡é†’äº†...." << endl;
    }, ref(pr));

    future<int> f = pr.get_future();
    int value = f.get();
    cout << "value: " << value << endl;

    t1.join();
    return 0;
}
```

> è¾“å‡º

```tex
value: 100
ç¡é†’äº†....
```

+ ç¤ºä¾‹ç¨‹åºçš„ä¸­å­çº¿ç¨‹çš„ä»»åŠ¡å‡½æ•°æŒ‡å®šçš„æ˜¯ä¸€ä¸ªåŒ¿åå‡½æ•°ï¼Œåœ¨è¿™ä¸ªåŒ¿åçš„ä»»åŠ¡å‡½æ•°æ‰§è¡ŒæœŸé—´é€šè¿‡`p.set_value(100);`ä¼ å‡ºäº†æ•°æ®å¹¶ä¸”æ¿€æ´»äº†çŠ¶æ€ï¼Œæ•°æ®å°±ç»ªåï¼Œå¤–éƒ¨ä¸»çº¿ç¨‹ä¸­çš„`int value = f.get();`è§£é™¤é˜»å¡ï¼Œå¹¶å°†å¾—åˆ°çš„æ•°æ®æ‰“å°å‡ºæ¥ï¼Œ5ç§’é’Ÿä¹‹åå­çº¿ç¨‹ä¼‘çœ ç»“æŸï¼ŒåŒ¿åçš„ä»»åŠ¡å‡½æ•°æ‰§è¡Œå®Œæ¯•ã€‚

#### **å­çº¿ç¨‹ä»»åŠ¡å‡½æ•°æ‰§è¡Œç»“æŸï¼Œè®©çŠ¶æ€å°±ç»ª**

```cpp
#include <iostream>
#include <thread>
#include <future>
using namespace std;

int main()
{
    promise<int> pr;
    thread t1([](promise<int> &p) {
        p.set_value_at_thread_exit(100);
        this_thread::sleep_for(chrono::seconds(3));
        cout << "ç¡é†’äº†...." << endl;
    }, ref(pr));

    future<int> f = pr.get_future();
    int value = f.get();
    cout << "value: " << value << endl;

    t1.join();
    return 0;
}
```

> ç¤ºä¾‹ç¨‹åºè¾“å‡ºçš„ç»“æœï¼š

```tex
ç¡é†’äº†....
value: 100
```

+ åœ¨ç¤ºä¾‹ç¨‹åºä¸­ï¼Œå­çº¿ç¨‹çš„è¿™ä¸ªåŒ¿åçš„ä»»åŠ¡å‡½æ•°ä¸­é€šè¿‡`p.set_value_at_thread_exit(100);`åœ¨æ‰§è¡Œå®Œæ¯•å¹¶é€€å‡ºä¹‹åæ‰ä¼šä¼ å‡ºæ•°æ®å¹¶æ¿€æ´»çŠ¶æ€ï¼Œæ•°æ®å°±ç»ªåï¼Œå¤–éƒ¨ä¸»çº¿ç¨‹ä¸­çš„`int value = f.get();`è§£é™¤é˜»å¡ï¼Œå¹¶å°†å¾—åˆ°çš„æ•°æ®æ‰“å°å‡ºæ¥ï¼Œå› æ­¤å­çº¿ç¨‹åœ¨ä¼‘çœ 5ç§’é’Ÿä¹‹åä¸»çº¿ç¨‹ä¸­æ‰èƒ½å¾—åˆ°ä¼ å‡ºçš„æ•°æ®ã€‚

+ å¦å¤–ï¼Œåœ¨è¿™ä¸¤ä¸ªå®ä¾‹ç¨‹åºä¸­æœ‰ä¸€ä¸ªçŸ¥è¯†ç‚¹éœ€è¦å¼ºè°ƒï¼Œåœ¨å¤–éƒ¨ä¸»çº¿ç¨‹ä¸­åˆ›å»ºçš„`promise`å¯¹è±¡å¿…é¡»è¦é€šè¿‡å¼•ç”¨çš„æ–¹å¼ä¼ é€’åˆ°å­çº¿ç¨‹çš„ä»»åŠ¡å‡½æ•°ä¸­ï¼Œåœ¨å®ä¾‹åŒ–å­çº¿ç¨‹å¯¹è±¡çš„æ—¶å€™ï¼Œå¦‚æœä»»åŠ¡å‡½æ•°çš„å‚æ•°æ˜¯å¼•ç”¨ç±»å‹ï¼Œé‚£ä¹ˆå®å‚ä¸€å®šè¦æ”¾åˆ°`std::ref()`å‡½æ•°ä¸­ï¼Œè¡¨ç¤ºè¦ä¼ é€’è¿™ä¸ªå®å‚çš„å¼•ç”¨åˆ°ä»»åŠ¡å‡½æ•°ä¸­ã€‚

<!-- tabs:end -->

### 3. std::packaged_task

+ `std::packaged_task`ç±»åŒ…è£…äº†ä¸€ä¸ªå¯è°ƒç”¨å¯¹è±¡åŒ…è£…å™¨ç±»å¯¹è±¡ï¼ˆå¯è°ƒç”¨å¯¹è±¡åŒ…è£…å™¨åŒ…è£…çš„æ˜¯å¯è°ƒç”¨å¯¹è±¡ï¼Œå¯è°ƒç”¨å¯¹è±¡éƒ½å¯ä»¥ä½œä¸ºå‡½æ•°æ¥ä½¿ç”¨ï¼‰ï¼Œè¿™ä¸ªç±»å¯ä»¥å°†å†…éƒ¨åŒ…è£…çš„å‡½æ•°å’Œ`future`ç±»ç»‘å®šåˆ°ä¸€èµ·ï¼Œä»¥ä¾¿è¿›è¡Œåç»­çš„å¼‚æ­¥è°ƒç”¨ï¼Œå®ƒå’Œstd::promiseæœ‰ç‚¹ç±»ä¼¼ï¼Œ`std::promise`å†…éƒ¨ä¿å­˜ä¸€ä¸ªå…±äº«çŠ¶æ€çš„å€¼ï¼Œè€Œ`std::packaged_task`ä¿å­˜çš„æ˜¯ä¸€ä¸ªå‡½æ•°

#### 3.1 ç±»æˆå‘˜å‡½æ•°

<!-- tabs:start -->

> é€šè¿‡ç±»çš„å®šä¹‰å¯ä»¥çœ‹åˆ°è¿™ä¹Ÿæ˜¯ä¸€ä¸ªæ¨¡æ¿ç±»ï¼Œæ¨¡æ¿ç±»å‹å’Œè¦åœ¨çº¿ç¨‹ä¸­ä¼ å‡ºçš„æ•°æ®ç±»å‹æ˜¯ä¸€è‡´çš„ã€‚

```cpp
// å®šä¹‰äºå¤´æ–‡ä»¶ <future>
template< class > class packaged_task;
template< class R, class ...Args >
class packaged_task<R(Args...)>;
```

#### **æ„é€ å‡½æ•°**

```cpp
// â‘ 
packaged_task() noexcept;
// â‘¡
template <class F>
explicit packaged_task( F&& f );
// â‘¢
packaged_task( const packaged_task& ) = delete;
// â‘£
packaged_task( packaged_task&& rhs ) noexcept;
```

1. æ„é€ å‡½æ•°â‘ ï¼šæ— å‚æ„é€ ï¼Œæ„é€ ä¸€ä¸ªæ— ä»»åŠ¡çš„ç©ºå¯¹è±¡
2. æ„é€ å‡½æ•°â‘¡ï¼šé€šè¿‡ä¸€ä¸ªå¯è°ƒç”¨å¯¹è±¡ï¼Œæ„é€ ä¸€ä¸ªä»»åŠ¡å¯¹è±¡
3. æ„é€ å‡½æ•°â‘¢ï¼šæ˜¾ç¤ºåˆ é™¤ï¼Œä¸å…è®¸é€šè¿‡æ‹·è´æ„é€ å‡½æ•°è¿›è¡Œå¯¹è±¡çš„æ‹·è´
4. æ„é€ å‡½æ•°â‘£ï¼šç§»åŠ¨æ„é€ å‡½æ•°

#### **å¸¸ç”¨å…¬å…±æˆå‘˜å‡½æ•°**

> é€šè¿‡è°ƒç”¨ä»»åŠ¡å¯¹è±¡å†…éƒ¨çš„`get_future()`æ–¹æ³•å°±å¯ä»¥å¾—åˆ°ä¸€ä¸ª`future`å¯¹è±¡ï¼ŒåŸºäºè¿™ä¸ªå¯¹è±¡å°±å¯ä»¥å¾—åˆ°ä¼ å‡ºçš„æ•°æ®äº†ã€‚
>

```cpp
std::future<R> get_future();
```

<!-- tabs:end -->

#### 3.2 packaged_taskçš„ä½¿ç”¨

> `packaged_task`å…¶å®å°±æ˜¯å¯¹å­çº¿ç¨‹è¦æ‰§è¡Œçš„ä»»åŠ¡å‡½æ•°è¿›è¡Œäº†åŒ…è£…ï¼Œå’Œå¯è°ƒç”¨å¯¹è±¡åŒ…è£…å™¨çš„ä½¿ç”¨æ–¹æ³•ç›¸åŒï¼ŒåŒ…è£…å®Œæ¯•ä¹‹åç›´æ¥å°†åŒ…è£…å¾—åˆ°çš„ä»»åŠ¡å¯¹è±¡ä¼ é€’ç»™çº¿ç¨‹å¯¹è±¡å°±å¯ä»¥äº†ã€‚

```cpp
#include <iostream>
#include <thread>
#include <future>
using namespace std;

int main()
{
    packaged_task<int(int)> task([](int x) {
        return x += 100;
    });

    thread t1(ref(task), 100);

    future<int> f = task.get_future();
    int value = f.get();
    cout << "value: " << value << endl;

    t1.join();
    return 0;
}
```

> åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä»£ç ä¸­ï¼Œé€šè¿‡`packaged_task`ç±»åŒ…è£…äº†ä¸€ä¸ªåŒ¿åå‡½æ•°ä½œä¸ºå­çº¿ç¨‹çš„ä»»åŠ¡å‡½æ•°ï¼Œæœ€ç»ˆçš„å¾—åˆ°çš„è¿™ä¸ªä»»åŠ¡å¯¹è±¡éœ€è¦é€šè¿‡å¼•ç”¨çš„æ–¹å¼ä¼ é€’åˆ°å­çº¿ç¨‹å†…éƒ¨ï¼Œè¿™æ ·æ‰èƒ½åœ¨ä¸»çº¿ç¨‹çš„æœ€åé€šè¿‡ä»»åŠ¡å¯¹è±¡å¾—åˆ°`future`å¯¹è±¡ï¼Œå†é€šè¿‡è¿™ä¸ª`future`å¯¹è±¡å–å‡ºå­çº¿ç¨‹é€šè¿‡è¿”å›å€¼ä¼ é€’å‡ºçš„æ•°æ®ã€‚

### 4. `std::async`

> `std::async`å‡½æ•°æ¯”å‰é¢æåˆ°çš„std::promiseå’Œ`packaged_taskæ›´`é«˜çº§ä¸€äº›ï¼Œå› ä¸ºé€šè¿‡è¿™å‡½æ•°å¯ä»¥ç›´æ¥å¯åŠ¨ä¸€ä¸ªå­çº¿ç¨‹å¹¶åœ¨è¿™ä¸ªå­çº¿ç¨‹ä¸­æ‰§è¡Œå¯¹åº”çš„ä»»åŠ¡å‡½æ•°ï¼Œå¼‚æ­¥ä»»åŠ¡æ‰§è¡Œå®Œæˆè¿”å›çš„ç»“æœä¹Ÿæ˜¯å­˜å‚¨åˆ°ä¸€ä¸ª`future`å¯¹è±¡ä¸­ï¼Œå½“éœ€è¦è·å–å¼‚æ­¥ä»»åŠ¡çš„ç»“æœæ—¶ï¼Œåªéœ€è¦è°ƒç”¨`future` ç±»çš„`get()`æ–¹æ³•å³å¯ï¼Œå¦‚æœä¸å…³æ³¨å¼‚æ­¥ä»»åŠ¡çš„ç»“æœï¼Œåªæ˜¯ç®€å•åœ°ç­‰å¾…ä»»åŠ¡å®Œæˆçš„è¯ï¼Œå¯ä»¥è°ƒç”¨`future` ç±»çš„`wait()`æˆ–è€…`wait_for()`æ–¹æ³•ã€‚è¯¥å‡½æ•°çš„å‡½æ•°åŸå‹å¦‚ä¸‹ï¼š

```cpp
// å®šä¹‰äºå¤´æ–‡ä»¶ <future>
// â‘ 
template< class Function, class... Args>
std::future<std::result_of_t<std::decay_t<Function>(std::decay_t<Args>...)>>
    async( Function&& f, Args&&... args );

// â‘¡
template< class Function, class... Args >
std::future<std::result_of_t<std::decay_t<Function>(std::decay_t<Args>...)>>
    async( std::launch policy, Function&& f, Args&&... args );
```

+ å¯ä»¥çœ‹åˆ°è¿™æ˜¯ä¸€ä¸ªæ¨¡æ¿å‡½æ•°ï¼Œåœ¨C++11ä¸­è¿™ä¸ªå‡½æ•°æœ‰ä¸¤ç§è°ƒç”¨æ–¹å¼ï¼š
  + å‡½æ•°â‘ ï¼šç›´æ¥è°ƒç”¨ä¼ é€’åˆ°å‡½æ•°ä½“å†…éƒ¨çš„å¯è°ƒç”¨å¯¹è±¡ï¼Œè¿”å›ä¸€ä¸ª`future`å¯¹è±¡
  + å‡½æ•°â‘¡ï¼šé€šè¿‡æŒ‡å®šçš„ç­–ç•¥è°ƒç”¨ä¼ é€’åˆ°å‡½æ•°å†…éƒ¨çš„å¯è°ƒç”¨å¯¹è±¡ï¼Œè¿”å›ä¸€ä¸ª`future`å¯¹è±¡

+ å‡½æ•°å‚æ•°:
  + `f`ï¼šå¯è°ƒç”¨å¯¹è±¡ï¼Œè¿™ä¸ªå¯¹è±¡åœ¨å­çº¿ç¨‹ä¸­è¢«ä½œä¸ºä»»åŠ¡å‡½æ•°ä½¿ç”¨
  + `Args`ï¼šä¼ é€’ç»™ `f` çš„å‚æ•°ï¼ˆå®å‚ï¼‰
  + `policy`ï¼šå¯è°ƒç”¨å¯¹è±¡Â·`f`çš„æ‰§è¡Œç­–ç•¥

|          ç­–ç•¥           |                             è¯´æ˜                             |
| :---------------------: | :----------------------------------------------------------: |
|  `std::launch::async`   |          è°ƒç”¨`async`å‡½æ•°æ—¶åˆ›å»ºæ–°çš„çº¿ç¨‹æ‰§è¡Œä»»åŠ¡å‡½æ•°           |
| `std::launch::deferred` | è°ƒç”¨`async`å‡½æ•°æ—¶ä¸æ‰§è¡Œä»»åŠ¡å‡½æ•°ï¼Œç›´åˆ°è°ƒç”¨äº†`future`çš„`get()`æˆ–è€…`wait()`æ—¶æ‰æ‰§è¡Œä»»åŠ¡ï¼ˆè¿™ç§æ–¹å¼ä¸ä¼šåˆ›å»ºæ–°çš„çº¿ç¨‹ï¼‰ |

> å…³äº`std::async`()å‡½æ•°çš„ä½¿ç”¨ï¼Œå¯¹åº”çš„ç¤ºä¾‹ä»£ç å¦‚ä¸‹ï¼š

#### 4.1 æ–¹å¼1

> è°ƒç”¨`async()`å‡½æ•°ç›´æ¥åˆ›å»ºçº¿ç¨‹æ‰§è¡Œä»»åŠ¡

```cpp
#include <iostream>
#include <thread>
#include <future>
using namespace std;

int main()
{
    cout << "ä¸»çº¿ç¨‹ID: " << this_thread::get_id() << endl;
    // è°ƒç”¨å‡½æ•°ç›´æ¥åˆ›å»ºçº¿ç¨‹æ‰§è¡Œä»»åŠ¡
    future<int> f = async([](int x) {
        cout << "å­çº¿ç¨‹ID: " << this_thread::get_id() << endl;
        this_thread::sleep_for(chrono::seconds(5));
        return x += 100;
    }, 100);

    future_status status;
    do {
        status = f.wait_for(chrono::seconds(1));
        if (status == future_status::deferred)
        {
            cout << "çº¿ç¨‹è¿˜æ²¡æœ‰æ‰§è¡Œ..." << endl;
            f.wait();
        }
        else if (status == future_status::ready)
        {
            cout << "å­çº¿ç¨‹è¿”å›å€¼: " << f.get() << endl;
        }
        else if (status == future_status::timeout)
        {
            cout << "ä»»åŠ¡è¿˜æœªæ‰§è¡Œå®Œæ¯•, ç»§ç»­ç­‰å¾…..." << endl;
        }
    } while (status != future_status::ready);

    return 0;
}
```

> ç¤ºä¾‹ç¨‹åºè¾“å‡ºçš„ç»“æœä¸ºï¼š

```tex
ä¸»çº¿ç¨‹ID: 8904
å­çº¿ç¨‹ID: 25036
ä»»åŠ¡è¿˜æœªæ‰§è¡Œå®Œæ¯•, ç»§ç»­ç­‰å¾…...
ä»»åŠ¡è¿˜æœªæ‰§è¡Œå®Œæ¯•, ç»§ç»­ç­‰å¾…...
ä»»åŠ¡è¿˜æœªæ‰§è¡Œå®Œæ¯•, ç»§ç»­ç­‰å¾…...
ä»»åŠ¡è¿˜æœªæ‰§è¡Œå®Œæ¯•, ç»§ç»­ç­‰å¾…...
ä»»åŠ¡è¿˜æœªæ‰§è¡Œå®Œæ¯•, ç»§ç»­ç­‰å¾…...
å­çº¿ç¨‹è¿”å›å€¼: 200
```

> è°ƒç”¨`async()`å‡½æ•°æ—¶ä¸æŒ‡å®šç­–ç•¥å°±æ˜¯ç›´æ¥åˆ›å»ºçº¿ç¨‹å¹¶æ‰§è¡Œä»»åŠ¡ï¼Œç¤ºä¾‹ä»£ç çš„ä¸»çº¿ç¨‹ä¸­åšäº†å¦‚ä¸‹æ“ä½œ`status = f.wait_for(chrono::seconds(1));`å…¶å®ç›´æ¥è°ƒç”¨`f.get()`å°±èƒ½å¾—åˆ°å­çº¿ç¨‹çš„è¿”å›å€¼ã€‚è¿™é‡Œä¸ºäº†ç»™å¤§å®¶æ¼”ç¤º`wait_for()`çš„ä½¿ç”¨ï¼Œæ‰€ä»¥å†™çš„å¤æ‚äº†äº›ã€‚

#### 4.2 æ–¹å¼2

> è°ƒç”¨`async()`å‡½æ•°ä¸åˆ›å»ºçº¿ç¨‹æ‰§è¡Œä»»åŠ¡

```cpp
#include <iostream>
#include <thread>
#include <future>
using namespace std;

int main()
{
    cout << "ä¸»çº¿ç¨‹ID: " << this_thread::get_id() << endl;
    // è°ƒç”¨å‡½æ•°ç›´æ¥åˆ›å»ºçº¿ç¨‹æ‰§è¡Œä»»åŠ¡
    future<int> f = async(launch::deferred, [](int x) {
        cout << "å­çº¿ç¨‹ID: " << this_thread::get_id() << endl;
        return x += 100;
    }, 100);

    this_thread::sleep_for(chrono::seconds(5));
    cout << f.get();

    return 0;
}
```

> ç¤ºä¾‹ç¨‹åºè¾“å‡ºçš„ç»“æœï¼š

```tex
ä¸»çº¿ç¨‹ID: 24760
ä¸»çº¿ç¨‹å¼€å§‹ä¼‘çœ 5ç§’...
å­çº¿ç¨‹ID: 24760
200
```

+ ç”±äºæŒ‡å®šäº†`launch::deferred` ç­–ç•¥ï¼Œå› æ­¤è°ƒç”¨`async()`å‡½æ•°å¹¶ä¸ä¼šåˆ›å»ºæ–°çš„çº¿ç¨‹æ‰§è¡Œä»»åŠ¡ï¼Œå½“ä½¿ç”¨`future`ç±»å¯¹è±¡è°ƒç”¨äº†`get()`æˆ–è€…`wait()`æ–¹æ³•åæ‰å¼€å§‹æ‰§è¡Œä»»åŠ¡ï¼ˆ`æ­¤å¤„ä¸€å®šè¦æ³¨æ„è°ƒç”¨wait_for()å‡½æ•°æ˜¯ä¸è¡Œçš„`ï¼‰ã€‚

+ é€šè¿‡æµ‹è¯•ç¨‹åºè¾“å‡ºçš„ç»“æœå¯ä»¥çœ‹åˆ°ï¼Œä¸¤æ¬¡è¾“å‡ºçš„çº¿ç¨‹IDæ˜¯ç›¸åŒçš„ï¼Œä»»åŠ¡å‡½æ•°æ˜¯åœ¨ä¸»çº¿ç¨‹ä¸­è¢«å»¶è¿Ÿï¼ˆä¸»çº¿ç¨‹ä¼‘çœ äº†5ç§’ï¼‰è°ƒç”¨äº†ã€‚

> æœ€ç»ˆæ€»ç»“ï¼š

1. `ä½¿ç”¨async()å‡½æ•°ï¼Œæ˜¯å¤šçº¿ç¨‹æ“ä½œä¸­æœ€ç®€å•çš„ä¸€ç§æ–¹å¼ï¼Œä¸éœ€è¦è‡ªå·±åˆ›å»ºçº¿ç¨‹å¯¹è±¡ï¼Œå¹¶ä¸”å¯ä»¥å¾—åˆ°å­çº¿ç¨‹å‡½æ•°çš„è¿”å›å€¼ã€‚`
2. `ä½¿ç”¨std::promiseç±»ï¼Œåœ¨å­çº¿ç¨‹ä¸­å¯ä»¥ä¼ å‡ºè¿”å›å€¼ä¹Ÿå¯ä»¥ä¼ å‡ºå…¶ä»–æ•°æ®ï¼Œå¹¶ä¸”å¯é€‰æ‹©åœ¨ä»€ä¹ˆæ—¶æœºå°†æ•°æ®ä»å­çº¿ç¨‹ä¸­ä¼ é€’å‡ºæ¥ï¼Œä½¿ç”¨èµ·æ¥æ›´çµæ´»ã€‚`
3. `ä½¿ç”¨std::packaged_taskç±»ï¼Œå¯ä»¥å°†å­çº¿ç¨‹çš„ä»»åŠ¡å‡½æ•°è¿›è¡ŒåŒ…è£…ï¼Œå¹¶ä¸”å¯ä»¥å¾—åˆ°å­çº¿ç¨‹çš„è¿”å›å€¼ã€‚`

### å¼‚æ­¥çº¿ç¨‹æ± å®ç°

> çº¿ç¨‹å¼‚æ­¥ï¼ˆAsynchronous Threadingï¼‰æ˜¯ä¸€ç§ç¼–ç¨‹èŒƒå¼ï¼Œç”¨äºæ‰§è¡Œä»»åŠ¡æˆ–æ“ä½œè€Œä¸é˜»å¡ä¸»çº¿ç¨‹æˆ–å…¶ä»–çº¿ç¨‹çš„æ‰§è¡Œã€‚è¿™ç§æ–¹æ³•ç‰¹åˆ«é€‚ç”¨äºéœ€è¦åŒæ—¶å¤„ç†å¤šä¸ªæ“ä½œæˆ–åœ¨åå°æ‰§è¡Œé•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡çš„åœºæ™¯ã€‚çº¿ç¨‹å¼‚æ­¥çš„æ ¸å¿ƒæ€æƒ³æ˜¯å°†è€—æ—¶çš„æ“ä½œä¸ä¸»æ‰§è¡Œæµç¨‹åˆ†ç¦»ï¼Œä½¿å¾—ç³»ç»Ÿèƒ½å¤Ÿç»§ç»­å¤„ç†å…¶ä»–ä»»åŠ¡ï¼Œè€Œæ— éœ€ç­‰å¾…è€—æ—¶æ“ä½œå®Œæˆã€‚

+ å¼‚æ­¥æ‰§è¡Œï¼šä¸åŒæ­¥æ“ä½œä¸åŒï¼Œå¼‚æ­¥æ“ä½œä¸è¦æ±‚è°ƒç”¨è€…åœ¨ä»»åŠ¡å®Œæˆä¹‹å‰ç­‰å¾…ç»“æœã€‚å¼‚æ­¥æ“ä½œé€šå¸¸ä¼šåœ¨åå°çº¿ç¨‹ä¸­æ‰§è¡Œï¼Œä¸»çº¿ç¨‹æˆ–å…¶ä»–çº¿ç¨‹å¯ä»¥ç»§ç»­æ‰§è¡Œå…¶ä»–ä»»åŠ¡ã€‚
+ çº¿ç¨‹ï¼šåœ¨å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­ï¼Œå¼‚æ­¥æ“ä½œé€šå¸¸é€šè¿‡åˆ›å»ºæ–°çš„çº¿ç¨‹æ¥å®ç°ã€‚æ–°çº¿ç¨‹ä¼šæ‰§è¡Œå¼‚æ­¥ä»»åŠ¡ï¼Œè€Œä¸»çº¿ç¨‹åˆ™ç»§ç»­è¿›è¡Œå…¶ä»–æ“ä½œã€‚
  åœ¨ä¸Šé¢çš„çº¿ç¨‹æ± ä»£ç ä¸­ï¼Œå¦‚æœä»»åŠ¡å‡½æ•°æœ‰è¿”å›å€¼ï¼Œæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡çº¿ç¨‹å¼‚æ­¥çš„æ–¹å¼ï¼Œå°†å­çº¿ç¨‹ä¹Ÿå°±æ˜¯å·¥ä½œçš„çº¿ç¨‹çš„è¿”å›å€¼ä¼ é€’ç»™ä¸»çº¿ç¨‹ï¼Œæ ¸å¿ƒæ“ä½œå°±æ˜¯ä¿®æ”¹æ·»åŠ ä»»åŠ¡çš„å‡½æ•°`addTask`ã€‚

> ä¸ºäº†è®©çº¿ç¨‹æ± æ·»åŠ ä»»åŠ¡çš„å‡½æ•°æ›´åŠ çµæ´»å’Œé€šè¿‡ä»¥åŠå®ç°çº¿ç¨‹å¼‚æ­¥ï¼Œæˆ‘ä»¬éœ€è¦å°†å…¶ä¿®æ”¹æˆä¸€ä¸ªæ¨¡æ¿å‡½æ•°ï¼š

> `ThreadPool.h`

```cpp
#pragma once
#include <thread>
#include <mutex>
#include <vector>
#include <queue>
#include <atomic>
#include <functional>
#include <condition_variable>
#include <map>
#include <future>
#include <memory>
using namespace std;

/*
æ„æˆï¼š
 1. ç®¡ç†è¿™è€…çº¿ç¨‹---> å­çº¿ç¨‹ 1ä¸ª
    - æ§åˆ¶å·¥ä½œçº¿ç¨‹çš„æ•°é‡ï¼šå¢åŠ æˆ–å‡å°‘
 2. è‹¥å¹²å·¥ä½œçº¿ç¨‹ ---> å­çº¿ç¨‹nä¸ª
    -ä»ä»»åŠ¡é˜Ÿåˆ—ä¸­å–ä»»åŠ¡ï¼Œå¹¶å¤„ç†
    -ä»»åŠ¡é˜Ÿåˆ—ä¸ºç©ºï¼Œè¢«é˜»å¡ï¼ˆè¢«æ¡ä»¶å˜é‡é˜»å¡ï¼‰
    -çº¿ç¨‹åŒæ­¥ï¼ˆäº’æ–¥é”ï¼‰
    -å½“å‰æ•°é‡ï¼Œç©ºé—²çš„çº¿ç¨‹æ•°é‡
    -æœ€å°ï¼Œæœ€å¤§çº¿ç¨‹æ•°é‡
 3. ä»»åŠ¡é˜Ÿåˆ—---> stlâ€”â€”>queue
    -äº’æ–¥é”
    -æ¡ä»¶å˜é‡
 4. çº¿ç¨‹æ± å¼€å…³â€”â€”> bool
*/

// çº¿ç¨‹æ± ç±»
class ThreadPool
{
public:
    ThreadPool(int min = 4, int max = thread::hardware_concurrency());
    ~ThreadPool();
    // æ·»åŠ ä»»åŠ¡  ---> ä»»åŠ¡é˜Ÿåˆ—
    // void addTask(function<void()> f);

    template<typename F, typename... Args>
    auto addTask(F&& f,Args&&... args) -> future<typename result_of<F(Args...)>::type> {
        // 1. package_task
        using returnType = typename result_of<F(Args...)>::type;
        auto mytask = make_shared<packaged_task<returnType()>>(
            bind(forward<F>(f), forward<Args>(args)...) //forward å®Œç¾è½¬å‘ï¼Œä¿è¯æ•°æ®çš„åŸå§‹ç±»å‹
        );
        // 2. å¾—åˆ°future
        future<returnType> res = mytask->get_future();
        // 3. ä»»åŠ¡å‡½æ•°æ·»åŠ åˆ°ä»»åŠ¡é˜Ÿåˆ—

        m_queueMutex.lock();
        m_tasks.emplace([mytask](){
            (*mytask)();
        });// mytaskæ˜¯æŒ‡é’ˆ  é¿å…å†…å­˜æ³„æ¼   å…±äº«èµ„æº
        m_queueMutex.unlock();

        m_condition.notify_one();// å”¤é†’ä¸€ä¸ªçº¿ç¨‹
        return res;
    }
private:
    void manager();
    void worker();
private:
    thread* m_manager;
    map<thread::id, thread> m_workers; 
    vector<thread::id> m_ids; 
    int m_minThreads;
    int m_maxThreads; 
    atomic<bool> m_stop; 
    atomic<int> m_curThreads;
    atomic<int> m_idleThreads;
    atomic<int> m_exitNumber; 
    queue<function<void()>> m_tasks;
    mutex m_idsMutex; 
    mutex m_queueMutex;
    condition_variable m_condition;
};
```

> `ThreadPool.cpp`

```cpp
#include "ThreadPool.h"
#include <iostream>

ThreadPool::ThreadPool(int min, int max) : m_maxThreads(max),
m_minThreads(min), m_stop(false), m_exitNumber(0)
{
    //m_idleThreads = m_curThreads = max / 2;
    m_idleThreads = m_curThreads = min;
    cout << "çº¿ç¨‹æ•°é‡: " << m_curThreads << endl;
    m_manager = new thread(&ThreadPool::manager, this);
    for (int i = 0; i < m_curThreads; ++i)
    {
        thread t(&ThreadPool::worker, this);
        m_workers.insert(make_pair(t.get_id(), move(t)));
    }
}

ThreadPool::~ThreadPool()
{
    m_stop = true;
    m_condition.notify_all();
    for (auto& it : m_workers)
    {
        thread& t = it.second;
        if (t.joinable())
        {
            cout << "******** çº¿ç¨‹ " << t.get_id() << " å°†è¦é€€å‡ºäº†..." << endl;
            t.join();
        }
    }
    if (m_manager->joinable())
    {
        m_manager->join();
    }
    delete m_manager;
}

// void ThreadPool::addTask(function<void()> f)
// {
//     {
//         lock_guard<mutex> locker(m_queueMutex);
//         m_tasks.emplace(f);
//     }
//     m_condition.notify_one();
// }

void ThreadPool::manager()
{
    while (!m_stop.load())
    {
        this_thread::sleep_for(chrono::seconds(2));
        int idle = m_idleThreads.load();
        int current = m_curThreads.load();
        if (idle > current / 2 && current > m_minThreads)
        {
            m_exitNumber.store(2);
            m_condition.notify_all();
            unique_lock<mutex> lck(m_idsMutex);
            for (const auto& id : m_ids)
            {
                auto it = m_workers.find(id);
                if (it != m_workers.end())
                {
                    cout << "############## çº¿ç¨‹ " << (*it).first << "è¢«é”€æ¯äº†...." << endl;
                    (*it).second.join();
                    m_workers.erase(it);
                }
            }
            m_ids.clear();
        }
        else if (idle == 0 && current < m_maxThreads)
        {
            thread t(&ThreadPool::worker, this);
            cout << "+++++++++++++++ æ·»åŠ äº†ä¸€ä¸ªçº¿ç¨‹, id: " << t.get_id() << endl;
            m_workers.insert(make_pair(t.get_id(), move(t)));
            m_curThreads++;
            m_idleThreads++;
        }
    }
}

void ThreadPool::worker()
{
    while (!m_stop.load())
    {
        function<void()> task = nullptr;
        {
            unique_lock<mutex> locker(m_queueMutex);
            while (!m_stop && m_tasks.empty())
            {
                m_condition.wait(locker);
                if (m_exitNumber.load() > 0)
                {
                    cout << "----------------- çº¿ç¨‹ä»»åŠ¡ç»“æŸ, ID: " << this_thread::get_id() << endl;
                    m_exitNumber--;
                    m_curThreads--;
                    unique_lock<mutex> lck(m_idsMutex);
                    m_ids.emplace_back(this_thread::get_id());
                    return;
                }
            }

            if (!m_tasks.empty())
            {
                cout << "å–å‡ºä¸€ä¸ªä»»åŠ¡..." << endl;
                task = move(m_tasks.front());
                m_tasks.pop();
            }
        }

        if (task)
        {
            m_idleThreads--;
            task();
            m_idleThreads++;
        }
    }
}

void calc(int x, int y)
{
    int res = x + y;
    cout << "res = " << res << endl;
    this_thread::sleep_for(chrono::seconds(2));
}

int calc1(int x,int y){
    int z = x + y;
    this_thread::sleep_for(chrono::seconds(2));
    return z;
}
int main()
{
    ThreadPool pool(4);
    vector<future<int>> results;
    for (int i = 0; i < 10; ++i)
    {
        // auto func = bind(calc, i, i * 2);
        results.emplace_back(pool.addTask(calc1,i,i*2));
    }
    for(auto& item : results){
        cout << "çº¿ç¨‹æ‰§è¡Œçš„ç»“æœï¼š" << item.get() << endl;//get æ˜¯é˜»å¡çš„
    }
    // getchar();
    return 0;
}
```

